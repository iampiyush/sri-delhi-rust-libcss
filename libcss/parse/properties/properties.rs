use wapcaplet::*;
use std::arc;

use bytecode::bytecode::*;
use bytecode::opcodes::*;

use include::fpmath::*;
use include::properties::*;

use lex::lexer::*;
use stylesheet::*;

use parse::propstrings::*;
use parse::properties::autogenerated::*;
use parse::properties::common::*;

use utils::errors::*;

pub type handle =  @extern fn(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style) ->css_error;
pub type reserved_fn = @extern fn (strings:&mut ~css_propstrings, ident:&@css_token) -> bool;
pub type get_value_fn = @extern fn (strings: &mut ~css_propstrings , token: &@css_token , first: bool) -> u32;

pub struct css_properties {
    property_handlers: ~[handle],
    sheet: @mut css_stylesheet
}

pub impl css_properties {

    pub fn css_properties(sheet_instance: @mut css_stylesheet) -> ~css_properties {

        /*
         * Dispatch table of property handlers, indexed by property enum
         */
        let mut vec = ~[
            @css_properties::css__parse_azimuth , //0
            @css_properties::css__parse_background , //1
            @css__parse_background_attachment, //2
            @css__parse_background_color, //3
            @css__parse_background_image, //4
            @css_properties::css__parse_background_position, //5
            @css__parse_background_repeat, //6
            @css_properties::css__parse_border, //7
            @css__parse_border_bottom, //8
            @css__parse_border_bottom_color, //9 
            @css__parse_border_bottom_style, //10
            @css__parse_border_bottom_width, //11
            @css__parse_border_collapse, //12
            @css_properties::css__parse_border_color, //13
            @css__parse_border_left, //14
            @css__parse_border_left_color, //15
            @css__parse_border_left_style, //16
            @css__parse_border_left_width, //17
            @css__parse_border_right, //18
            @css__parse_border_right_color, //19
            @css__parse_border_right_style, //20
            @css__parse_border_right_width, //21        
            @css_properties::css__parse_border_spacing, //22
            @css_properties::css__parse_border_style, //23
            @css__parse_border_top, //24
            @css__parse_border_top_color, //25
            @css__parse_border_top_style, //26
            @css__parse_border_top_width, //27
            @css_properties::css__parse_border_width, //28
            @css__parse_bottom, //29
            @css__parse_break_after, //30
            @css__parse_break_before, //31
            @css__parse_break_inside, //32
            @css__parse_caption_side, //33
            @css__parse_clear, //34
            @css_properties::css__parse_clip, //35
            @css__parse_color, //36
            @css_properties::css__parse_columns, //37
            @css__parse_column_count, //38
            @css__parse_column_fill, //39
            @css__parse_column_gap, //40
            @css_properties::css__parse_column_rule, //41
            @css__parse_column_rule_color, //42
            @css__parse_column_rule_style, //43
            @css__parse_column_rule_width, //44
            @css__parse_column_span, //45
            @css__parse_column_width, //46
            @css_properties::css__parse_content, //47
            @css__parse_counter_increment, //48
            @css__parse_counter_reset, //49
            @css_properties::css__parse_cue, //50
            @css__parse_cue_after, //51
            @css__parse_cue_before, //52
            @css_properties::css__parse_cursor, //53
            @css__parse_direction, //54
            @css__parse_display, //55
            @css_properties::css__parse_elevation, //56
            @css__parse_empty_cells, //57
            @css__parse_float, //58
            @css_properties::css__parse_font, //59
            @css_properties::css__parse_font_family, //60
            @css__parse_font_size, //61
            @css__parse_font_style, //62
            @css__parse_font_variant, //63
            @css_properties::css__parse_font_weight, //64
            @css__parse_height, //65
            @css__parse_left, //66
            @css__parse_letter_spacing, //67
            @css__parse_line_height, //68
            @css_properties::css__parse_list_style, //69
            @css__parse_list_style_image, //70
            @css__parse_list_style_position, //71
            @css_properties::css__parse_list_style_type, //72
            @css_properties::css__parse_margin, //73
            @css__parse_margin_bottom, //74
            @css__parse_margin_left, //75
            @css__parse_margin_right, //76
            @css__parse_margin_top, //77
            @css__parse_max_height, //78
            @css__parse_max_width, //79
            @css__parse_min_height, //80
            @css__parse_min_width, //81
            @css_properties::css__parse_opacity, //82
            @css__parse_orphans, //83
            @css_properties::css__parse_outline, //84
            @css__parse_outline_color, //85
            @css__parse_outline_style, //86
            @css__parse_outline_width, //87
            @css__parse_overflow, //88
            @css_properties::css__parse_padding, //89
            @css__parse_padding_bottom, //90
            @css__parse_padding_left, //91
            @css__parse_padding_right, //92
            @css__parse_padding_top, //93
            @css__parse_page_break_after, //94
            @css__parse_page_break_before, //95
            @css__parse_page_break_inside, //96
            @css_properties::css__parse_pause, //97
            @css__parse_pause_after, //98
            @css__parse_pause_before, //99
            @css__parse_pitch_range, //100
            @css__parse_pitch, //101
            @css_properties::css__parse_play_during, //102
            @css__parse_position, //103
            @css_properties::css__parse_quotes, //104
            @css__parse_richness, //105
            @css__parse_right, //106
            @css__parse_speak_header, //107
            @css__parse_speak_numeral, //108
            @css__parse_speak_punctuation, //109
            @css__parse_speak, //110
            @css__parse_speech_rate, //111
            @css__parse_stress, //112
            @css__parse_table_layout, //113
            @css__parse_text_align, //114
            @css_properties::css__parse_text_decoration, //115
            @css__parse_text_indent, //116
            @css__parse_text_transform, //117
            @css__parse_top, //118
            @css__parse_unicode_bidi, //119
            @css__parse_vertical_align, //120
            @css__parse_visibility, //121
            @css_properties::css__parse_voice_family, //122
            @css__parse_volume, //123
            @css__parse_white_space, //124
            @css__parse_widows, //125
            @css__parse_width, //126
            @css__parse_word_spacing, //127
            @css__parse_z_index, //128
        ];
        
        ~css_properties{
            property_handlers: vec,
            sheet: sheet_instance
        }
    }


    /**
    * Parse azimuth
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_azimuth(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx:uint = *ctx;
        let mut flags:u8 = 0;
        let mut  value:u16 = 0;
        // let mut unit:u32 = 0;
        let mut return_length_val = None;
        let mut return_unit_val = None;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        let mut token=&vector[*ctx];
        if ( 
            match (token.token_type) {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) 
        ) {
            *ctx += 1;
            flags = FLAG_INHERIT as u8 ;
        }
        else if ( 
            match (token.token_type) {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFTWARDS as uint)
        ) {
            *ctx += 1;
            value = AZIMUTH_LEFTWARDS ;
        }        
        else if ( 
            match (token.token_type) {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHTWARDS as uint) 
        ) {
            *ctx += 1;
            value = AZIMUTH_RIGHTWARDS ;
        }
        else if ( 
            match (token.token_type) {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } 
        ) {
            if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT_SIDE as uint) {
                value = AZIMUTH_LEFT_SIDE ;
            }

            else if ( 
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FAR_LEFT as uint) 
            ) {
                value = AZIMUTH_FAR_LEFT ;
            }
            else if ( 
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) 
            ) {
                value = AZIMUTH_LEFT ;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER_LEFT as uint) 
            ) {
                value = AZIMUTH_CENTER_LEFT ;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER as uint) 
            ) {
                value = AZIMUTH_CENTER;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),CENTER_RIGHT as uint) 
            ) {
                value = AZIMUTH_CENTER_RIGHT;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) 
            ) {
                value = AZIMUTH_RIGHT;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FAR_RIGHT as uint) 
            ) {
                value = AZIMUTH_FAR_RIGHT;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT_SIDE as uint) 
            ) {
                value = AZIMUTH_RIGHT_SIDE;
            }
            else if ( 
             strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BEHIND as uint) 
            ) {
                value = AZIMUTH_BEHIND;
            }
            else {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            consumeWhitespace(vector, ctx);
            token=&vector[*ctx];

            if (
                match (token.token_type) {
                    CSS_TOKEN_IDENT  => true,
                    _=> false
                } && value == AZIMUTH_BEHIND
            ) {
                *ctx += 1;
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT_SIDE as uint) {
                    value |= AZIMUTH_LEFT_SIDE;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FAR_LEFT as uint) {
                    value |= AZIMUTH_FAR_LEFT;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
                    value |= AZIMUTH_LEFT;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER_LEFT as uint) {
                    value |= AZIMUTH_CENTER_LEFT;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER as uint) {
                    value |=  AZIMUTH_CENTER;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER_RIGHT as uint) {
                    value |= AZIMUTH_CENTER_RIGHT;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
                    value |= AZIMUTH_RIGHT;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FAR_RIGHT as uint) {
                    value |= AZIMUTH_FAR_RIGHT;
                }
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT_SIDE as uint) {
                    value |= AZIMUTH_RIGHT_SIDE;
                }
                else {
                *ctx = orig_ctx;
                return CSS_INVALID;
                }
            }
            else if  (
                match (token.token_type) {
                    CSS_TOKEN_IDENT  => true,
                    _=> false
                }&& value != AZIMUTH_BEHIND
            ) {
                *ctx += 1;
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BEHIND as uint) {
                    value |= AZIMUTH_BEHIND;
                }
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            } 
            else if (
                match (token.token_type) {
                    CSS_TOKEN_IDENT  => false,
                    _=> true
                } && value == AZIMUTH_BEHIND
            ) {
                value |= AZIMUTH_CENTER;
            }
        } 
        else{
            let (length_val , unit_val , result) = css__parse_unit_specifier(sheet , vector, ctx, UNIT_DEG as u32);
            return_length_val = length_val;
            return_unit_val = unit_val;
            match result {
                CSS_OK => {},
                _ => {
                    *ctx = orig_ctx;
                    return result;
                }
            }
            if (unit_val.unwrap() & UNIT_ANGLE as u32) == 0 {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            if (unit_val.unwrap() == UNIT_DEG as u32) {
                if ((length_val.unwrap() < -F_360) || (length_val.unwrap() > F_360)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            else if (unit_val.unwrap() == UNIT_GRAD as u32) {
                if ((length_val.unwrap() < -F_400) || (length_val.unwrap() > F_400)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            } 
            else if (unit_val.unwrap() == UNIT_RAD as u32) {
                if ((length_val.unwrap() < -F_2PI) || (length_val.unwrap() > F_2PI)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            value = AZIMUTH_ANGLE;
        }

        css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_AZIMUTH, flags, value);

        if (((flags & FLAG_INHERIT as u8) == 0) && (value == AZIMUTH_ANGLE)) {
            css_stylesheet::css__stylesheet_style_vappend(style, [return_length_val.unwrap() as u32 , return_unit_val.unwrap() as u32]);
        }
        CSS_OK
    }


    /**
    * Parse background
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    pub fn css__parse_background(sheet:@mut css_stylesheet, strings: &mut ~css_propstrings, vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error {
        let orig_ctx = *ctx;
        let mut prev_ctx;
        let mut error = CSS_OK; 
        let mut attachment = true;
        let mut color = true;
        let mut image = true;
        let mut position = true;
        let mut repeat = true;
        let attachment_style:@mut css_style;
        let color_style:@mut css_style;
        let image_style:@mut css_style;
        let position_style:@mut css_style;
        let repeat_style:@mut css_style;
        let mut background_cleanup = false;

        /* Firstly, handle inherit */
        if *ctx >= vector.len() {
            return CSS_INVALID   
        }
            
        let mut token = &vector[*ctx];
            
        if is_css_inherit(strings, token) {
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_ATTACHMENT);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_IMAGE);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_POSITION);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_REPEAT);
            if *ctx >= vector.len() {
                return CSS_INVALID   
            }
            // token = &vector[*ctx];
            *ctx +=1; //Iterate
            return CSS_OK
        } 

        /* allocate styles */
        attachment_style = css_stylesheet::css__stylesheet_style_create(sheet);
        color_style = css_stylesheet::css__stylesheet_style_create(sheet);
        image_style = css_stylesheet::css__stylesheet_style_create(sheet);
        position_style = css_stylesheet::css__stylesheet_style_create(sheet);
        repeat_style = css_stylesheet::css__stylesheet_style_create(sheet);

        /* Attempt to parse the various longhand properties */
        loop {
            prev_ctx = *ctx;
            
            if (is_css_inherit(strings, token)) {
                error = CSS_INVALID;
                background_cleanup = true;
                break
            }

            /* Try each property parser in turn, but only if we
             * haven't already got a value for this property.
             */
            
            if attachment &&  match css__parse_background_attachment(sheet, strings, vector, ctx, 
                attachment_style) { CSS_OK => true, x =>{ error = x; false}} {
                attachment = false
            } 
            else if color &&  match css__parse_background_color(sheet, strings, vector, ctx,
                color_style) { CSS_OK => true, x =>{ error = x; false}} {
                color = false
            } 
            else if image &&  match css__parse_background_image(sheet, strings, vector, ctx,
                image_style) { CSS_OK => true, x =>{ error = x; false}} {
                image = false
            } 
            else if position && match css_properties::css__parse_background_position(sheet, strings, vector, ctx,
             position_style) { CSS_OK => true, x =>{ error = x; false}} {
                position = false
            } else if repeat && match css__parse_background_repeat(sheet, strings, vector, ctx,
             repeat_style){ CSS_OK => true, x => {error = x; false}} {
                repeat = false
            }

            match error {
                CSS_OK => {
                    consumeWhitespace(vector, ctx);
                    if *ctx >= vector.len() {
                        break   
                    }
                    token = &vector[*ctx];
                },
                _ =>  break //Forcibly cause loop to exit
            }

            if *ctx == prev_ctx {
                break
            }
        } 

        if !background_cleanup{
            if attachment {
                css_stylesheet::css__stylesheet_style_appendOPV(attachment_style, CSS_PROP_BACKGROUND_ATTACHMENT, 0, 
                    BACKGROUND_ATTACHMENT_SCROLL ); 
            }

            if color {
                css_stylesheet::css__stylesheet_style_appendOPV(color_style, CSS_PROP_BACKGROUND_COLOR, 0, 
                    BACKGROUND_COLOR_TRANSPARENT );
            }

            if image {
                css_stylesheet::css__stylesheet_style_appendOPV(image_style, CSS_PROP_BACKGROUND_IMAGE, 0, BACKGROUND_IMAGE_NONE );
            }

            if position {
                css_stylesheet::css__stylesheet_style_appendOPV(position_style, CSS_PROP_BACKGROUND_POSITION, 0, 
                    BACKGROUND_POSITION_HORZ_LEFT  |  BACKGROUND_POSITION_VERT_TOP )
            }

            if repeat {
                css_stylesheet::css__stylesheet_style_appendOPV(repeat_style, CSS_PROP_BACKGROUND_REPEAT, 0,
                 BACKGROUND_REPEAT_REPEAT ) 
            }   
        
            css_stylesheet::css__stylesheet_merge_style(result, attachment_style);
            css_stylesheet::css__stylesheet_merge_style(result, color_style);
            css_stylesheet::css__stylesheet_merge_style(result, image_style);
            css_stylesheet::css__stylesheet_merge_style(result, position_style);
            css_stylesheet::css__stylesheet_merge_style(result, repeat_style);
        }
        
        match error { 
            CSS_OK => return CSS_OK,
            x => {
                *ctx = orig_ctx ;
                return x 
            }
        }
    }
 

    /**
    * Parse background_position
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_background_position(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,
        vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        let mut orig_ctx = *ctx;
        let mut flags:u8 = 0;
        let mut value = [0,0]; //u16
        let mut length= [0,0]; //i32
        let mut unit = [0,0]; //u32
        

        /* [length | percentage | IDENT(left, right, top, bottom, center)]{1,2}
         * | IDENT(inherit) */
         if *ctx >= vector.len() {
            return CSS_INVALID   
        }
            
        let mut token = &vector[*ctx];

        if match token.token_type { CSS_TOKEN_IDENT  => true, _ => false }  
            && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),INHERIT as uint) {
            
            //token = &vector[*ctx]; Value assigned never used
            *ctx += 1;
            flags = FLAG_INHERIT as u8;
        } 
        else {
            let mut second_pass = false;
            for uint::range(0,2) |i| {
                if *ctx >= vector.len() {
                    break   
                }
            
                token = &vector[*ctx];

                match token.token_type {
                    CSS_TOKEN_IDENT  => {
                        if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
                            value[i] = BACKGROUND_POSITION_HORZ_LEFT 
                        } 
                        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
                            value[i] = BACKGROUND_POSITION_HORZ_RIGHT 
                        } 
                        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TOP as uint) {
                            value[i] = BACKGROUND_POSITION_VERT_TOP 
                        }
                        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BOTTOM as uint) {
                            value[i] = BACKGROUND_POSITION_VERT_BOTTOM 
                        }
                        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER as uint) {
                            value[i] = BACKGROUND_POSITION_VERT_CENTER 
                        }
                        else if (i == 1) {
                            /* Second pass, so ignore this one */
                            break;
                        } else {
                            /* First pass, so invalid */
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        *ctx += 1; //Iterate
                    },    
                
                    CSS_TOKEN_DIMENSION | CSS_TOKEN_NUMBER | CSS_TOKEN_PERCENTAGE => {
                        match css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32){                               
                            (Some(length_val), Some(unit_val), CSS_OK) => {
                                length[i] = length_val as i32;
                                unit[i] = unit_val
                            },
                            (_,_,error) => {
                                *ctx = orig_ctx;
                                return error;
                            }
                        }
                                                
                        if (unit[i] & UNIT_ANGLE as u32) != 0 || (unit[i] & UNIT_TIME as u32) != 0 || (unit[i] & UNIT_FREQ as u32) != 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        /* We'll fix this up later, too */
                        value[i] = BACKGROUND_POSITION_VERT_SET ;
                    }, 
                    _  => {
                        if i == 1 {
                            /* Second pass, so ignore */
                            second_pass = true;
                            break;
                        } 
                        else {
                            /* First pass, so invalid */
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    }
                }    
                consumeWhitespace(vector, ctx);
            }

            //assert(i != 0);

            /* Now, sort out the mess we've got */
            if second_pass {
                assert!(BACKGROUND_POSITION_VERT_CENTER == BACKGROUND_POSITION_HORZ_CENTER);

                /* Only one value, so the other is center */
                if value[0] == BACKGROUND_POSITION_HORZ_LEFT  ||
                    value[0] == BACKGROUND_POSITION_HORZ_RIGHT  || 
                    value[0] == BACKGROUND_POSITION_VERT_CENTER  ||
                    value[0] == BACKGROUND_POSITION_VERT_TOP  ||
                    value[0] == BACKGROUND_POSITION_VERT_BOTTOM  {

                }
                else if value[0] == BACKGROUND_POSITION_VERT_SET  {
                  value[0] = BACKGROUND_POSITION_HORZ_SET  
                } 
                
                value[1] = BACKGROUND_POSITION_VERT_CENTER ;
            } 
            else if value[0] != BACKGROUND_POSITION_VERT_SET  && value[1] != BACKGROUND_POSITION_VERT_SET  {
                /* Two keywords. Verify the axes differ */
                if (((value[0] & 0xf) != 0 && (value[1] & 0xf) != 0) || ((value[0] & 0xf0) != 0 && (value[1] & 0xf0) != 0)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            } 
            else {
                /* One or two non-keywords. First is horizontal */
                if value[0] == BACKGROUND_POSITION_VERT_SET  {
                    value[0] = BACKGROUND_POSITION_HORZ_SET 
                }
                    

                /* Verify the axes differ */
                if (((value[0] & 0xf) != 0 && (value[1] & 0xf) != 0) ||
                        ((value[0] & 0xf0) != 0 && 
                            (value[1] & 0xf0) != 0)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }

        css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_BACKGROUND_POSITION, flags, value[0] | value[1]);
        

        if ((flags & FLAG_INHERIT as u8) == 0) {
            if value[0] == BACKGROUND_POSITION_HORZ_SET  {
                css_stylesheet::css__stylesheet_style_append(style, length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style, unit[0])
            }
            if (value[1] == BACKGROUND_POSITION_VERT_SET ) {
                css_stylesheet::css__stylesheet_style_append(style, length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style, unit[1])
            }
        }

        return CSS_OK;
    }


    /**
    * Parse border
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_border(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut error: css_error;

        error = css__parse_border_side(sheet , strings , vector , ctx , style , BORDER_SIDE_TOP);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
                return error;
            }
        }

        *ctx = orig_ctx;
        error = css__parse_border_side(sheet , strings , vector , ctx , style , BORDER_SIDE_RIGHT);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
                return error;
            }
        }

        *ctx = orig_ctx;
        error = css__parse_border_side(sheet , strings , vector , ctx , style , BORDER_SIDE_BOTTOM);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
                return error;
            }
        }

        *ctx = orig_ctx;
        error = css__parse_border_side(sheet , strings , vector , ctx , style , BORDER_SIDE_LEFT);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
            }
        }
        return error;
    }


    /**
    * Parse border_color
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_border_color(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut prev_ctx: uint;
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        let mut token=&vector[*ctx];

        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_TOP_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_RIGHT_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_BOTTOM_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_LEFT_COLOR);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut side_val_vec: ~[u16] = ~[]; 
        let mut side_color_vec: ~[u32] = ~[];
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            let (side_val,side_color , result) = css__parse_color_specifier(sheet , strings , vector , ctx);

            match result {
                CSS_OK => {
                    side_count += 1;
                    consumeWhitespace(vector , ctx);
                    token=&vector[*ctx];
                    side_val_vec.push(side_val.unwrap());
                    side_color_vec.push(side_color.unwrap());
                },
                _ => {
                    break
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }

        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[1] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[1] as u32)
                }
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[1] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[2]);
                if side_val_vec[2] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[2] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[1] as u32)
                }
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[1] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[2]);
                if side_val_vec[2] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[2] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[3]);
                if side_val_vec[3] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_val_vec[3] as u32)
                }
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * Parse border_spacing
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_border_spacing(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut error: css_error; 
        let mut length:~[i32] = ~[];
        let mut unit:~[u32] = ~[];

        /* Firstly, handle inherit */
        if *ctx >= vector.len() {
            return CSS_INVALID   
        }
            
        let mut token = &vector[*ctx];

        if ( 
            match (token.token_type) {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) 
        ) {
            *ctx += 1;
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_SPACING , FLAG_INHERIT as u8 , 0);
        }
        else {
            let mut num_lengths :int;
            let (length_opt,unit_opt,result) = css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
            length.push(length_opt.unwrap() as i32);
            unit.push(unit_opt.unwrap());
            error =result;
            match error {
                CSS_OK=> {
                    if (unit[0] & UNIT_ANGLE as u32) > 0  || (unit[0] & UNIT_TIME as u32) > 0  || 
                        (unit[0] & UNIT_FREQ as u32) > 0  || (unit[0] & UNIT_PCT as u32 ) > 0 {

                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    num_lengths = 1;
                    consumeWhitespace(vector, ctx);

                    if *ctx < vector.len() {
                        let (length_opt,unit_opt,result) = css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
                        length.push(length_opt.unwrap() as i32);
                        unit.push(unit_opt.unwrap());
                        error =result;
                         match error {
                            CSS_OK=> {
                                if (unit[1] & UNIT_ANGLE as u32) > 0 ||
                                   (unit[1] & UNIT_TIME as u32) > 0 ||
                                   (unit[1] & UNIT_FREQ  as u32) > 0 ||
                                   (unit[1] & UNIT_PCT as u32) > 0 {
                    
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                num_lengths = 2;
                            },
                            _=>{}
                        }
                    }//end of *ctx < vector.len()
                    if (num_lengths == 1) {
                     /* Only one length specified. Use for both axes. */
                        length[1] = length[0];
                        unit[1] = unit[0];
                    }

                    /* Lengths must not be negative */
                    if (length[0] < 0 || length[1] < 0) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_BORDER_SPACING, 0, BORDER_SPACING_SET );
                    css_stylesheet::css__stylesheet_style_vappend(style,[ length[0] as u32, unit[0] , length[1] as u32, unit[1] ]); 
                },
                _=>{
                   *ctx = orig_ctx;
                    return error; 
                }
            }
        }
        CSS_OK
    }


    /**
    * Parse border_style
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_border_style(_: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut prev_ctx: uint;
        let mut token: &@css_token;
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];

        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_TOP_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_RIGHT_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_BOTTOM_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_LEFT_STYLE);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut side_val_vec: ~[u16] = ~[]; 
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            match token.token_type {
                CSS_TOKEN_IDENT  => {
                    if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , NONE as uint) {
                        side_val_vec.push(BORDER_STYLE_NONE );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , HIDDEN as uint) {
                        side_val_vec.push(BORDER_STYLE_HIDDEN );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , DOTTED as uint) {
                        side_val_vec.push(BORDER_STYLE_DOTTED );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , DASHED as uint) {
                        side_val_vec.push(BORDER_STYLE_DASHED );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , SOLID as uint) {
                        side_val_vec.push(BORDER_STYLE_SOLID );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , LIBCSS_DOUBLE as uint) {
                        side_val_vec.push(BORDER_STYLE_DOUBLE );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , GROOVE as uint) {
                        side_val_vec.push(BORDER_STYLE_GROOVE );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , RIDGE as uint) {
                        side_val_vec.push(BORDER_STYLE_RIDGE );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , INSET as uint) {
                        side_val_vec.push(BORDER_STYLE_INSET );
                    }
                    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , OUTSET as uint) {
                        side_val_vec.push(BORDER_STYLE_OUTSET );
                    }
                    else {
                        break;
                    }
                },
                _ => {
                    break
                }
            }
            side_count += 1;
            *ctx = *ctx + 1;
            consumeWhitespace(vector , ctx);
            
            if *ctx >= vector.len() {
                break;
            }

            token=&vector[*ctx];

            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[0]);
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[1]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[1]);
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[1]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[2]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[1]);
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[1]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[2]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[3]);
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * Parse border_width
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_border_width(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut error: css_error= CSS_OK;
        let mut token: &@css_token;
        let mut side_val: ~[u16] = ~[];
        let mut side_length: ~[i32] = ~[];
        let mut side_unit: ~[u32] = ~[];
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];

        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_TOP_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_RIGHT_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_BOTTOM_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_LEFT_WIDTH);
            *ctx += 1;
            return CSS_OK;
        }
        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            if (
                match token.token_type {
                    CSS_TOKEN_IDENT  => true,
                    _ => false
                }
                ) && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , THIN as uint) {

                side_val.push(BORDER_WIDTH_THIN);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else if (
                match token.token_type {
                    CSS_TOKEN_IDENT  => true,
                    _ => false
                }
                ) && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , MEDIUM as uint) {
                
                side_val.push(BORDER_WIDTH_MEDIUM);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else if (match token.token_type {
                CSS_TOKEN_IDENT  => true,
                _ => false
            }) && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , THICK as uint) {
                
                side_val.push(BORDER_WIDTH_THICK);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else {
                side_val.push(BORDER_WIDTH_SET);
                let (_ , _ , result) = css__parse_unit_specifier(sheet , vector, ctx, UNIT_PX as u32);
                match result {
                    CSS_OK => {
                        if (side_unit[side_count] == (UNIT_PCT as u32)) {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_ANGLE as u32)) > 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_TIME as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_FREQ as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        if side_length[side_count] < 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    },
                    _ => {}
                }
            }
            match error {
                CSS_OK => {
                    side_count += 1;
                    consumeWhitespace(vector , ctx);

                    if *ctx >= vector.len() {
                        break;
                    }

                    token=&vector[*ctx];
                }
                _ => {
                    break
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[2]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[2]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[3]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[3] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[3] as u32);
            },
            _ => {
                *ctx = orig_ctx;
            }
        }
        CSS_OK
    }


    /**
    * Parse clip
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_clip(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut token: &@css_token;
        let mut num_lengths: int = 0;
        let mut length: ~[i32] = ~[];
        let mut unit: ~[u32] = ~[]; 

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        *ctx = *ctx + 1;

        match token.token_type {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , INHERIT as uint) {
                    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_CLIP , FLAG_INHERIT as u8 , 0);
                }
                else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , AUTO as uint) {
                    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_CLIP , 0 , CLIP_AUTO );
                }
            },
            CSS_TOKEN_FUNCTION  => {
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , RECT as uint) {
                    let mut i: int = 0;
                    let mut value: u16 = CLIP_SHAPE_RECT ;

                    while i < 4 {
                        consumeWhitespace(vector , ctx);

                        if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        token=&vector[*ctx];

                        match token.token_type {
                            CSS_TOKEN_IDENT  => {
                                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , AUTO as uint) {
                                    value |= 1 << (i+3);
                                }
                                else {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                *ctx = *ctx + 1;
                            }
                            _ => {
                                let (length_val , unit_val , result) = css__parse_unit_specifier(sheet , vector, ctx, UNIT_PX as u32);
                                
                                match result {
                                    CSS_OK => {},
                                    _ => {
                                        *ctx = orig_ctx;
                                        return result;
                                    }
                                }
                                length.push(length_val.unwrap() as i32);
                                unit.push(unit_val.unwrap());
                                if (unit[num_lengths] & (UNIT_ANGLE as u32)) > 0 {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                if (unit[num_lengths] & (UNIT_TIME as u32)) > 0{
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                if (unit[num_lengths] & (UNIT_FREQ as u32)) > 0{
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                if (unit[num_lengths] & (UNIT_PCT as u32)) > 0{
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                num_lengths += 1;
                            }
                                    
                        }
                        consumeWhitespace(vector , ctx);
                        if i<3 {
                            if *ctx >= vector.len() {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                            token=&vector[*ctx];
                            if tokenIsChar(token , ',') {
                                *ctx = *ctx + 1;
                            }
                        }
                        i += 1;
                    }

                    /* Finally, consume closing parenthesis */
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    token=&vector[*ctx];
                    *ctx = *ctx + 1;

                    if (tokenIsChar(token , ')') == false) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_CLIP , 0 , value);

                    while i < num_lengths {
                        css_stylesheet::css__stylesheet_style_vappend(style,[ length[i] as u32, unit[i]]);
                        num_lengths += 1;
                    }
                }
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * Parse columns
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_columns(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let mut prev_ctx:uint;
        let mut token:&@css_token;
        let mut width = true;
        let mut count = true;
        let mut error_width: css_error;
        let mut error_count: css_error;
        let mut error =true;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        
        if (is_css_inherit(strings, token)) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_COUNT);
            *ctx += 1;
            return CSS_OK;
        }

        let mut width_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut count_style = css_stylesheet::css__stylesheet_style_create(sheet);

        loop {
            prev_ctx = *ctx;
            if (is_css_inherit(strings, token)) {
                return CSS_INVALID;
            }
            error_width= css__parse_column_width(sheet , strings ,vector, ctx,  width_style);
            error_count= css__parse_column_count(sheet , strings ,vector, ctx,  count_style);
            if (width &&
                match error_width {
                    CSS_OK=>true,
                    _=>false
                }
            ) {
                width = false;
                error =false;
            }
 
            else if (count &&
                match error_count{
                    CSS_OK=>true,
                    _=>false
                }
                ) {
                count = false;
                error =false;
            }
            if(!error) {
                consumeWhitespace(vector, ctx);
                if *ctx >= vector.len() {
                    break;
                }
                token =&vector[*ctx];
            }
            else {
                break
            }
            if *ctx == prev_ctx {
                break;
            }
        }//end of loop

        if width {
            css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_COLUMN_WIDTH, 0, COLUMN_WIDTH_AUTO);
        }
        if count {
            css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_COLUMN_COUNT, 0, COLUMN_COUNT_AUTO);
        }
        css_stylesheet::css__stylesheet_merge_style(style , width_style);
        css_stylesheet::css__stylesheet_merge_style(style , count_style);

        CSS_OK
    }


    /**
    * Parse column_rule
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_column_rule(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut color = true;
        let mut bool_style = true;
        let mut width = true;
        let mut error: css_error = CSS_OK;
        let mut token: &@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];

        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_RULE_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_RULE_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_RULE_WIDTH);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut color_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut style_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut width_style = css_stylesheet::css__stylesheet_style_create(sheet);

        let mut prev_ctx: uint;

        loop {
            prev_ctx = *ctx;

            if *ctx >= vector.len() {
                return CSS_INVALID;
            }
            
            token=&vector[*ctx];
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            if ((color) && 
                (match (css__parse_column_rule_color(sheet , strings , vector , ctx , color_style)) {
                    CSS_OK => true,
                    _ => false
                })) {
                color = false;
                error = CSS_OK;
            }
            
            else if (bool_style) && 
                (match (css__parse_column_rule_style(sheet , strings , vector , ctx , style_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                bool_style = false;
                error = CSS_OK;
            }
            else if (width) && 
                (match (css__parse_column_rule_width(sheet , strings , vector , ctx , width_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                width = false;
                error = CSS_OK;
            }
            match error {
                CSS_OK => {
                    consumeWhitespace(vector , ctx);

                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if (*ctx == prev_ctx) {
                break;
            }
        }

        if color {
            css_stylesheet::css__stylesheet_style_appendOPV(color_style , CSS_PROP_COLUMN_RULE_COLOR , 0 , COLUMN_RULE_COLOR_SET );
            css_stylesheet::css__stylesheet_style_append(color_style , 0x00000000);
        }
        if bool_style {
            css_stylesheet::css__stylesheet_style_appendOPV(style_style , CSS_PROP_COLUMN_RULE_STYLE , 0 , COLUMN_RULE_STYLE_NONE );   
        }
        if width {
            css_stylesheet::css__stylesheet_style_appendOPV(width_style , CSS_PROP_COLUMN_RULE_WIDTH , 0 , COLUMN_RULE_WIDTH_MEDIUM );
        }

        css_stylesheet::css__stylesheet_merge_style(style , color_style);
        css_stylesheet::css__stylesheet_merge_style(style , style_style);
        css_stylesheet::css__stylesheet_merge_style(style , width_style);
        CSS_OK
    }


    /**
    * Parse content
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_content(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, result: @mut css_style)->css_error {
        let mut orig_ctx = *ctx;
        let mut error:css_error = CSS_OK;                
        /* IDENT(normal, none, inherit) | [ ... ]+ */
        
        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        let mut token=&vector[*ctx];
        *ctx = *ctx + 1; //Iterate

        let token_ident_match_res = match token.token_type { CSS_TOKEN_IDENT  => true, _ => false};

        if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),INHERIT as uint) {
           css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_CONTENT)        
        }
        else if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),NORMAL as uint) {
           css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CONTENT, 0, CONTENT_NORMAL )
        } 
        else if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
           css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CONTENT, 0, CONTENT_NONE )
        } 
        else {

                /* Macro to output the value marker, awkward because we need to check
                 * first to determine how the value is constructed.
                 */
                let CSS_APPEND = |first, CSSVAL| css_stylesheet::css__stylesheet_style_append(result, if first {buildOPV(CSS_PROP_CONTENT, 0, CSSVAL)} else {CSSVAL as u32});

                let mut first = true;
                let mut prev_ctx = orig_ctx;

                /* [
                 *   IDENT(open-quote, close-quote, no-open-quote,
                 *         no-close-quote) |
                 *   STRING |
                 *   URI |
                 *   FUNCTION(attr) IDENT ')' |
                 *   FUNCTION(counter) IDENT IDENT? ')' |
                 *   FUNCTION(counters) IDENT STRING IDENT? ')'
                 * ]+
                 */

            loop {
                if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),
                 OPEN_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_OPEN_QUOTE )
                }
                else if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),
                 CLOSE_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_CLOSE_QUOTE )
                }
                else if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),
                 NO_OPEN_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_NO_OPEN_QUOTE );
                } 
                else if token_ident_match_res && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),
                 NO_CLOSE_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_NO_CLOSE_QUOTE );
                } 
                else if match token.token_type {CSS_TOKEN_STRING  => true, _ => false} {
                    
                    let snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone())) ;
                    CSS_APPEND(first, CONTENT_STRING );
                    
                    css_stylesheet::css__stylesheet_style_append(result, snumber as u32);
                }
                else if match token.token_type {CSS_TOKEN_URI  => true, _ => false} {
                    
                    match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()){
                        (CSS_OK, Some(uri)) => {
                            let uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri));
                            CSS_APPEND(first, CONTENT_URI);
                    
                            css_stylesheet::css__stylesheet_style_append(result, uri_snumber as u32)
                        },
                        (error, _ ) => {
                            *ctx = orig_ctx;
                            return error
                        }
                    }
                } 
                else if match token.token_type {CSS_TOKEN_FUNCTION  => true, _ => false} &&
                        strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ATTR as uint) {

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx = *ctx + 1; //Iterate
                    
                    match token.token_type { 
                        CSS_TOKEN_IDENT  => {},
                        _ => {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }   
                    
                    let snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone()));
                    CSS_APPEND(first, CONTENT_ATTR );
                    
                    css_stylesheet::css__stylesheet_style_append(result, snumber as u32);

                    consumeWhitespace(vector, ctx);

                    /* Expect ')' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx = *ctx + 1; //Iterate
                    
                    if !tokenIsChar(token, ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                }
                else if match token.token_type {CSS_TOKEN_FUNCTION  => true, _ => false} &&
                       strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), COUNTER as uint) {
                                       
                    let mut opv = CONTENT_COUNTER as u32;

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx = *ctx + 1; //Iterate
                    
                    match token.token_type { 
                        CSS_TOKEN_IDENT  => {},
                        _ => {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }   

                    let name = token.idata.get_ref().clone();

                    consumeWhitespace(vector, ctx);

                    /* Possible ',' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    
                    if !tokenIsChar(token, ',') && !tokenIsChar(token, ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    if tokenIsChar(token, ',') {

                        *ctx += 1;

                        consumeWhitespace(vector, ctx);

                        /* Expect IDENT */
                        if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                        
                        token=&vector[*ctx]; //peek
                        
                        match token.token_type { 
                            CSS_TOKEN_IDENT  => {},
                            _ => {
                                *ctx = orig_ctx;
                                return CSS_INVALID
                            }
                        }   
                        
                        let value:u32; 
                        match css__parse_list_style_type_value(strings , token){
                            (Some(val), CSS_OK) => {value = val as u32},
                            ( _, error) => {
                                *ctx = orig_ctx;
                                return error;
                            }
                        }
                        
                        opv |= value << CONTENT_COUNTER_STYLE_SHIFT as uint;

                        *ctx += 1;

                        consumeWhitespace(vector, ctx);
                    } 
                    else {
                        opv |= LIST_STYLE_TYPE_DECIMAL as u32 << CONTENT_COUNTER_STYLE_SHIFT as uint
                    }

                    /* Expect ')' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    
                    if !tokenIsChar(token, ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    let snumber = sheet.css__stylesheet_string_add(lwc_string_data(name));
                    
                    CSS_APPEND(first, opv as u16);
                    
                    css_stylesheet::css__stylesheet_style_append(result, snumber as u32);
                } 
                else if match token.token_type {CSS_TOKEN_FUNCTION  => true, _ => false} &&
                       strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), COUNTERS as uint) {
                                      
                    let mut opv = CONTENT_COUNTERS as u32;

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                        
                        token=&vector[*ctx];
                        *ctx += 1; //Iterate

                        match token.token_type { 
                            CSS_TOKEN_IDENT  => {},
                            _ => {
                                *ctx = orig_ctx;
                                return CSS_INVALID
                            }
                        }   
                    
                    let name = token.idata.get_ref().clone();

                    consumeWhitespace(vector, ctx);

                    /* Expect ',' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    if !tokenIsChar(token, ',') {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    
                    consumeWhitespace(vector, ctx);

                    /* Expect STRING */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    match token.token_type{
                        CSS_TOKEN_STRING  => {},
                        _ => { 
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }    

                    let sep = token.idata.get_ref().clone();

                    consumeWhitespace(vector, ctx);

                    /* Possible ',' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    if !tokenIsChar(token, ',') && !tokenIsChar(token, ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }

                    if tokenIsChar(token, ',') {
                                               
                       *ctx += 1;

                        consumeWhitespace(vector, ctx);

                        /* Expect IDENT */
                         if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    
                        token=&vector[*ctx];
                        
                        match token.token_type {
                            CSS_TOKEN_IDENT  => {},
                            _ => {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                        }    

                        let value:u32; 
                        match css__parse_list_style_type_value(strings , token){
                            (Some(val), CSS_OK) => {value = val as u32},
                            ( _, error) => {
                                *ctx = orig_ctx;
                                return error;
                            }
                        }
                        
                        opv |= value as u32 << CONTENT_COUNTERS_STYLE_SHIFT as uint;

                        *ctx += 1;

                        consumeWhitespace(vector, ctx);
                    } 
                    else {
                        opv |= LIST_STYLE_TYPE_DECIMAL as u32 << CONTENT_COUNTERS_STYLE_SHIFT as uint;
                    }

                    /* Expect ')' */
                    
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    if !tokenIsChar(token, ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }


                    let name_snumber = sheet.css__stylesheet_string_add(lwc_string_data(name));
                   
                    let sep_snumber = sheet.css__stylesheet_string_add(lwc_string_data(sep));
                    
                    CSS_APPEND(first, opv as u16);
                    
                    css_stylesheet::css__stylesheet_style_append(result, name_snumber as u32);
                    
                    css_stylesheet::css__stylesheet_style_append(result, sep_snumber as u32)
                }
                else if (first) {
                    /* Invalid if this is the first iteration */
                    error = CSS_INVALID;
                } 
                else {
                    /* Give up, ensuring current token is reprocessed */
                    *ctx = prev_ctx;
                    error = CSS_OK;
                    break;
                }

                /* if there was an error bail */
                match error {
                    CSS_OK => {},
                     _ => {
                        *ctx = orig_ctx;
                        return error;
                    }
                }    

                first = false;

                consumeWhitespace(vector, ctx);

                prev_ctx = *ctx;
                
                if *ctx >= vector.len() {
                    break
                }
                
                token=&vector[*ctx];
                *ctx += 1; //Iterate
            } /* loop */

            /* Write list terminator */
            css_stylesheet::css__stylesheet_style_append(result, CONTENT_NORMAL as u32);
        }

        match error {
            CSS_OK => {},
             _ => {
                *ctx = orig_ctx;
                return error;
            }
        }    
    
        CSS_OK
    }


    /**
    * Parse cue
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_cue(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut error: css_error;
        let mut token:&@css_token;
        let mut first_token:&@css_token;

        first_token=&vector[*ctx];

        error = css__parse_cue_before(sheet , strings , vector , ctx , style);

        match error {
            CSS_OK => {
                consumeWhitespace(vector , ctx);

                if *ctx >= vector.len() {
                    *ctx = orig_ctx;
                    error = css__parse_cue_after(sheet , strings , vector , ctx , style);
                }
                else {
                    token = &vector[*ctx];
                    if is_css_inherit(strings , token) {
                        error = CSS_INVALID;
                    }
                    else {
                        error = css__parse_cue_after(sheet , strings , vector , ctx , style);
                        match error {
                            CSS_OK => {
                                if is_css_inherit(strings , first_token) {
                                    error = CSS_INVALID;
                                }
                            },
                            _ => {
                                *ctx = orig_ctx;
                                error = css__parse_cue_after(sheet , strings , vector , ctx , style);
                            }           
                        }       
                    }
                }
            },
            _ => {}
        }
        match error {
            CSS_OK => {
                return CSS_OK;
            },
            _ => {
                *ctx = orig_ctx;
                return error
            }
        }
    }


    /**
    * Parse cursor
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_cursor(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut token: &@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token = &vector[*ctx];
        *ctx = *ctx + 1;
        
        match token.token_type {
            CSS_TOKEN_IDENT  =>{},
            CSS_TOKEN_URI  => {},
            _=>{
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        if (
            match token.token_type {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint)
            ) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_CURSOR);
        }
        else {
            let mut first : bool =true;
            let mut uri_snumber:u32;
            while (*ctx < vector.len() 
                && match token.token_type {
                        CSS_TOKEN_URI  => true,
                        _ => false
                   }
                   ) {

                let mut uri:arc::RWARC<~lwc_string>;
                match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()) {
                    (CSS_OK, Some(x)) => {
                        uri =x;
                    },
                    (error,_) => {
                        *ctx = orig_ctx;
                        return error;
                    }
                }
                uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri)) as u32;
                match first{
                    true=>{
                         css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_URI );
                    },
                    false=>{
                        css_stylesheet::css__stylesheet_style_append(style,CURSOR_URI as u32);
                    }
                }
                css_stylesheet::css__stylesheet_style_append(style,uri_snumber);

                consumeWhitespace(vector, ctx);
                if *ctx >= vector.len() {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
                token = &vector[*ctx];
                *ctx = *ctx + 1;

                if tokenIsChar(token, ',') == false {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                consumeWhitespace(vector, ctx);
                if *ctx >= vector.len() {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
                token = &vector[*ctx];
                *ctx = *ctx + 1;
                match token.token_type {
                    CSS_TOKEN_IDENT  =>{},
                    CSS_TOKEN_URI  => {},
                    _=>{
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                }
                first = false;
            }//end of while

            match token.token_type {
                CSS_TOKEN_IDENT =>{
                   if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_AUTO );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_AUTO as u32);
                            }
                        }
                    }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CROSSHAIR as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_CROSSHAIR );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_CROSSHAIR as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DEFAULT as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_DEFAULT );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_DEFAULT as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), POINTER as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_POINTER );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_POINTER as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MOVE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_MOVE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_MOVE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), E_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_E_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_E_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NE_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_NE_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_NE_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NW_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_NW_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_NW_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(),N_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_N_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_N_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SE_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_SE_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_SE_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SW_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_SW_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_SW_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), S_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_S_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_S_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), W_RESIZE as uint) {
                         match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_W_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_W_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_TEXT as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_TEXT );
                            },
                            false=>{
                                 css_stylesheet::css__stylesheet_style_append(style,CURSOR_TEXT as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), WAIT as uint) {
                         match first{
                                true=>{
                                    css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_WAIT );
                                },
                                false=>{
                                    css_stylesheet::css__stylesheet_style_append(style,CURSOR_WAIT as u32);
                                }
                            }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HELP as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_HELP );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_HELP as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), PROGRESS as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_PROGRESS );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_PROGRESS as u32);
                            }
                        }
                   }
                   else {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                   }
                },
                _=>{}
            }
        }//end else

        CSS_OK
    }


    /**
    * Parse elevation
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_elevation(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx:uint = *ctx;
        let mut flags:u8 = 0;
        let mut value:u16= 0;
        let mut length:i32 = 0;
        let mut unit:u32 = 0;
        let mut token:&@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        
        if (
            match token.token_type {
                CSS_TOKEN_IDENT =>true,
                _=>false
            } && 
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) 
        ) {
            *ctx += 1;
            flags = FLAG_INHERIT as u8;
        }
        else if (
            match token.token_type {
                CSS_TOKEN_IDENT =>true,
                 _=>false
            } &&
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BELOW as uint)
            ) {
                *ctx += 1;
                value = ELEVATION_BELOW ;
            }
        else if (
            match token.token_type {
                CSS_TOKEN_IDENT =>true,
                 _=>false
            } &&
         strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEVEL as uint)
         ) {
                *ctx += 1;
                value = ELEVATION_LEVEL ;
            }
        else if (
            match token.token_type {
                CSS_TOKEN_IDENT =>true,
                 _=>false
            } &&
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ABOVE as uint)
            ) {
                *ctx += 1;
                value = ELEVATION_ABOVE ;
            }
        else if (
            match token.token_type {
                CSS_TOKEN_IDENT =>true,
                 _=>false
            } &&
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIGHER as uint) 
            ){
                *ctx += 1;
                value = ELEVATION_HIGHER ;
            }
        else if (
            match token.token_type {
                CSS_TOKEN_IDENT =>true,
                 _=>false
            } &&
            strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LOWER as uint)
            ) {
                *ctx += 1;
                value = ELEVATION_LOWER ;
            }
        else {
            let (unit_ret,length_ret,error) = css__parse_unit_specifier(sheet , vector, ctx, UNIT_DEG as u32);
            length = length_ret.unwrap() as i32;
            unit = unit_ret.unwrap() as u32;
            match error {
                CSS_OK=>{
                    if ((unit & UNIT_ANGLE as u32) ==0) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    /* Valid angles lie between -90 and 90 degrees */
                    if (unit == UNIT_DEG as u32) {
                        if (length < -F_90 as i32 || length > F_90 as i32) {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    } 
                    else if (unit == UNIT_GRAD as u32) {
                        if (length < -F_100  as i32|| length > F_100 as i32) {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    } 
                    else if (unit == UNIT_RAD as u32) {
                        if (length < -F_PI_2  as i32|| length > F_PI_2 as i32) {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    }
                    value = ELEVATION_ANGLE ;
                },
                _=>{
                    *ctx = orig_ctx;
                    return error; 
                }
            }
        }
           
        css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_ELEVATION, flags, value);

        if (((flags & FLAG_INHERIT as u8) > 0) && (value == ELEVATION_ANGLE )) {
            css_stylesheet::css__stylesheet_style_vappend(style, [length as u32 , unit as u32]);
        }
        CSS_OK
    }


    /**
    * Parse font
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_font(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let mut prev_ctx: uint;
        let mut token: &@css_token;
        let mut bool_style = true;
        let mut variant = true;
        let mut weight = true;
        let mut line_height = true;
        let mut svw: int;
        let mut error: css_error;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];

        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_VARIANT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_WEIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_SIZE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LINE_HEIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_FAMILY);

            *ctx = *ctx + 1;
            return CSS_OK;
        }

        match sheet.font {
            None => {},
            Some(font_resolution) => {
                let (sheet_font_error , some_sys_font) = (*font_resolution)(token.idata.get_ref().clone());
                match token.token_type {
                    CSS_TOKEN_IDENT  => {
                        let value_from_font = match some_sys_font {
                            None => false,
                            _ => match sheet_font_error {
                                 CSS_OK => true,
                                 _ => false   
                            }
                        };
                        if value_from_font {
                            error  = parse_system_font(sheet , strings , style , some_sys_font.unwrap());
                            match error {
                                CSS_OK => {
                                    *ctx = *ctx + 1;
                                    return error;
                                },
                                _=> {
                                    return error;
                                }
                            }
                        }
                    },
                    _ => {}
                }
            }
        }

        let style_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let variant_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let weight_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let size_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let line_height_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let family_style = css_stylesheet::css__stylesheet_style_create(sheet);

        svw = 0;
        while svw < 3 {
            prev_ctx = *ctx;

            if *ctx >= vector.len() {
               return CSS_INVALID;
            }
            token = &vector[*ctx];

            if is_css_inherit(strings , token) {
                return CSS_INVALID;
            }

            let mut bool_error_style: bool = match css__parse_font_style(sheet , strings , vector , ctx , style_style) {
                CSS_OK => true,
                _ => false
            };
            let mut bool_error_variant = match css__parse_font_variant(sheet , strings , vector , ctx , variant_style) {
                CSS_OK => true,
                _ => false
            };
            let mut bool_error_weight = match css_properties::css__parse_font_weight(sheet , strings , vector , ctx , weight_style) {
                CSS_OK => true,
                _ => false
            };

            if bool_style && bool_error_style {
                bool_style = false;
            }
            else if variant && bool_error_variant {
                variant = false;
            }
            else if weight && bool_error_weight {
                weight = false;
            }

            if bool_error_style||bool_error_variant||bool_error_weight {
                consumeWhitespace(vector , ctx);
            }
            else {
                break;
            }
            if *ctx == prev_ctx {
                break;
            }
            svw += 1;
        }

        consumeWhitespace(vector , ctx);

        if *ctx >= vector.len() {
           return CSS_INVALID;
        }
        token = &vector[*ctx];

        if is_css_inherit(strings , token) {
            return CSS_INVALID;
        }

        error = css__parse_font_size(sheet , strings , vector , ctx , size_style);
        match error {
            CSS_OK => {},
            _ => {
                return error;
            }
        }

        consumeWhitespace(vector , ctx);

        if *ctx >= vector.len() {
           return CSS_INVALID;
        }
        token = &vector[*ctx];

        if tokenIsChar(token , '/') {
            *ctx += 1;

            consumeWhitespace(vector , ctx);
            if *ctx >= vector.len() {
                return CSS_INVALID;
            }

            token = &vector[*ctx];
            if is_css_inherit(strings , token) {
                return CSS_INVALID;
            }

            error = css__parse_line_height(sheet , strings , vector , ctx , line_height_style);
            match error {
                CSS_OK => {},
                _ => {
                    return error;
                }
            }
            line_height = false;
        }

        consumeWhitespace(vector , ctx);

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token = &vector[*ctx];

        if is_css_inherit(strings , token) {
            return CSS_INVALID;
        }

        error = css_properties::css__parse_font_family(sheet , strings , vector , ctx , family_style);
        match error {
            CSS_OK => {},
            _ => {
                return error;
            }
        }

        if bool_style {
            css_stylesheet::css__stylesheet_style_appendOPV(style_style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_NORMAL );
        }
        if variant {
            css_stylesheet::css__stylesheet_style_appendOPV(variant_style , CSS_PROP_FONT_VARIANT , 0 , FONT_VARIANT_NORMAL );   
        }
        if weight {
            css_stylesheet::css__stylesheet_style_appendOPV(weight_style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_NORMAL );
        }
        if line_height {
            css_stylesheet::css__stylesheet_style_appendOPV(line_height_style , CSS_PROP_LINE_HEIGHT , 0 , LINE_HEIGHT_NORMAL );
        }

        css_stylesheet::css__stylesheet_merge_style(style , style_style);
        css_stylesheet::css__stylesheet_merge_style(style , variant_style);
        css_stylesheet::css__stylesheet_merge_style(style , weight_style);
        css_stylesheet::css__stylesheet_merge_style(style , size_style);
        css_stylesheet::css__stylesheet_merge_style(style , line_height_style);
        css_stylesheet::css__stylesheet_merge_style(style , family_style);

        CSS_OK
    }


    /**
    * Parse font_family
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    pub fn css__parse_font_family(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings, vector:&~[@css_token], ctx: @mut uint, result: @mut css_style) -> css_error {
    
        let orig_ctx = *ctx;
        
        /* [ IDENT+ | STRING ] [ ',' [ IDENT+ | STRING ] ]* | IDENT(inherit)
         * 
         * In the case of IDENT+, any whitespace between tokens is collapsed to
         * a single space
         *
         * \todo Mozilla makes the comma optional. 
         * Perhaps this is a quirk we should inherit?
         */

        if *ctx >= vector.len() {
            return CSS_INVALID
        }

        let token = &vector[*ctx];
        *ctx +=1; //Iterate
        
        if match token.token_type { CSS_TOKEN_IDENT  | CSS_TOKEN_STRING  => false, _ => true } {
            *ctx = orig_ctx;
            return CSS_INVALID
        }

        if match token.token_type { CSS_TOKEN_IDENT  => true, _ => false } && 
        strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
            
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_FONT_FAMILY)
        } 
        else {
            *ctx = orig_ctx;
            let error = css__comma_list_to_style(sheet , strings , vector , ctx , Some(@font_family_reserved) , Some(@font_family_value) , result);
            match error {
                CSS_OK => {},
                _ => {
                    *ctx = orig_ctx;
                    return error;
                }
            }

            css_stylesheet::css__stylesheet_style_append(result, FONT_FAMILY_END as u32);
        }

        CSS_OK
    }

 
    /**
    * Parse font_weight
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_font_weight(_: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut flags:u8 = 0;
        let mut value:u16= 0;
        let mut token:&@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        *ctx += 1;

        if (match token.token_type { 
            CSS_TOKEN_IDENT  | CSS_TOKEN_NUMBER => false,
            _ => true 
        }) {
            *ctx = orig_ctx;
            return CSS_INVALID
        }
        
        if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
            flags |= FLAG_INHERIT as u8;
        }
        else if (
            match token.token_type {
                CSS_TOKEN_NUMBER => true,
                _ => false 
            } ) 
        {
            let mut (num,consumed) =  css__number_from_lwc_string(token.idata.get_ref().clone(), true);
            if (consumed !=  lwc_string_length(token.idata.get_ref().clone())){
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            match css_int_to_fixed(num as int) {
                100 => value = FONT_WEIGHT_100 ,
                200 => value = FONT_WEIGHT_200 ,
                300 => value = FONT_WEIGHT_300 ,
                400 => value = FONT_WEIGHT_400 ,
                500 => value = FONT_WEIGHT_500 ,
                600 => value = FONT_WEIGHT_600 ,
                700 => value = FONT_WEIGHT_700 ,
                800 => value = FONT_WEIGHT_800 ,
                900 => value = FONT_WEIGHT_900 ,
                _=>{
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }

        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
            value = FONT_WEIGHT_NORMAL ;
        }
        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BOLD as uint) {
            value = FONT_WEIGHT_BOLD ;
        }
        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BOLDER as uint) {
            value = FONT_WEIGHT_BOLDER ;
        }
        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIGHTER as uint) {
            value = FONT_WEIGHT_LIGHTER ;
        }
        else  {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        css_stylesheet::css__stylesheet_style_appendOPV(style,  CSS_PROP_FONT_WEIGHT,flags, value);
        CSS_OK
    }


    /**
    * Parse list_style
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_list_style(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut token: &@css_token;
        let mut image = true;
        let mut position = true;
        let mut type_type = true;
        let mut error: css_error= CSS_OK;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];

        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LIST_STYLE_IMAGE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LIST_STYLE_POSITION);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LIST_STYLE_TYPE);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut image_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut position_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut type_style = css_stylesheet::css__stylesheet_style_create(sheet);

        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if *ctx >= vector.len() {
                return CSS_INVALID;
            }
            
            token=&vector[*ctx];
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                error = CSS_INVALID;
            }

            if ((type_type) && 
                (match (css_properties::css__parse_list_style_type(sheet , strings , vector , ctx , type_style)) {
                    CSS_OK => true,
                    _ => false
                })) {
                type_type = false;
                error = CSS_OK;
            }
            
            else if (position) && 
                (match (css__parse_list_style_position(sheet , strings , vector , ctx , position_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                position = false;
                error = CSS_OK;
            }
            else if (image) && 
                (match (css__parse_list_style_image(sheet , strings , vector , ctx , image_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                image = false;
                error = CSS_OK;
            }
            match error {
                CSS_OK => {
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if *ctx == prev_ctx {
                break;
            }
        }

        if image {
            css_stylesheet::css__stylesheet_style_appendOPV(image_style , CSS_PROP_LIST_STYLE_IMAGE , 0 , LIST_STYLE_IMAGE_NONE );
        }
        if position {
            css_stylesheet::css__stylesheet_style_appendOPV(position_style , CSS_PROP_LIST_STYLE_POSITION , 0 , LIST_STYLE_POSITION_OUTSIDE );   
        }
        if type_type {
            css_stylesheet::css__stylesheet_style_appendOPV(type_style , CSS_PROP_LIST_STYLE_TYPE , 0 , LIST_STYLE_TYPE_DISC );
        }

        css_stylesheet::css__stylesheet_merge_style(style , image_style);
        css_stylesheet::css__stylesheet_merge_style(style , position_style);
        css_stylesheet::css__stylesheet_merge_style(style , type_style);

        CSS_OK
    }


    /**
    * Parse list_style_type
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_list_style_type(_: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut token: &@css_token;
        let mut flags: u8 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        *ctx += 1;
        match token.token_type {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , INHERIT as uint) {
                    flags |= FLAG_INHERIT as u8;
                }
                else {
                    let (_ , error) = css__parse_list_style_type_value(strings , token);
                    match error {
                        CSS_OK => {},
                        _ => {
                            *ctx = orig_ctx;
                            return error;
                        }
                    }
                }
            }
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        let (list_type , _) = css__parse_list_style_type_value(strings , token);
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_LIST_STYLE_TYPE , flags , list_type.unwrap());
        CSS_OK
    }


    /**
    * Parse margin
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_margin(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut error: css_error= CSS_OK;
        let mut token: &@css_token;
        let mut side_val: ~[u16] = ~[];
        let mut side_length: ~[i32] = ~[];
        let mut side_unit: ~[u32] = ~[];
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_TOP);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_RIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_BOTTOM);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_LEFT);
            *ctx += 1;
            return CSS_OK;
        }

        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            if (match token.token_type {
                CSS_TOKEN_IDENT  => true,
                _ => false
            }) && strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , AUTO as uint) {

                side_val.push(MARGIN_AUTO);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else {
                side_val.push(MARGIN_SET );
                let (_ , _ , result) = css__parse_unit_specifier(sheet , vector, ctx, UNIT_PX as u32);
                
                match result {
                    CSS_OK => {
                        if (side_unit[side_count] & (UNIT_ANGLE as u32)) > 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_TIME as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_FREQ as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    },
                    _ => {}
                }
            }
            match error {
                CSS_OK => {
                    side_count += 1;
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                    token=&vector[*ctx];
                }
                _ => {
                    break
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[2]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[1]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[2]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[3]);
                css_stylesheet::css__stylesheet_style_append(style , side_length[3] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[3] as u32);
            },
            _ => {
                *ctx = orig_ctx;
            }
        }
        CSS_OK
    }


    /**
    * Parse opacity
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_opacity(_: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx:uint = *ctx;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }

        let mut token=&vector[*ctx];
        *ctx += 1;
        
        match token.token_type {
            CSS_TOKEN_IDENT =>{
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
                    css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OPACITY);
                }
            },
            CSS_TOKEN_NUMBER=>{
                    let mut (num,consumed) =  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
                    /* Invalid if there are trailing characters */
                    if (consumed !=  lwc_string_length(token.idata.get_ref().clone())){
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    // /* Clamp to range [0,1] */
                    if num < 0 {
                        num = 0;
                    }
                    if num as i32 > css_int_to_fixed(1) {
                        num = css_int_to_fixed(1);
                    }

                    css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_OPACITY, 0, OPACITY_SET );
                    css_stylesheet::css__stylesheet_style_append(style, num as u32);
            },
            _=>{
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }

    
    /**
    * Parse outline
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_outline(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut token: &@css_token;
        let mut color =true;
        let mut style_bool =true;
        let mut width =true;
        let mut error: css_error = CSS_OK;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        if (is_css_inherit(strings , token)) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OUTLINE_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OUTLINE_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OUTLINE_WIDTH);
            *ctx +=1;
            return CSS_OK;
        }
        
        let mut color_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut style_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let mut width_style = css_stylesheet::css__stylesheet_style_create(sheet);

        let mut prev_ctx: uint;

        loop {
            prev_ctx = *ctx;
            
            if *ctx >= vector.len() {
                return CSS_INVALID;
            }

            token=&vector[*ctx];
            
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                error = CSS_INVALID;
            }

            if ((color) && 
                (match (css__parse_outline_color(sheet , strings , vector , ctx , color_style)) {
                    CSS_OK => true,
                    _ => false
                })) {
                color = false;
                error = CSS_OK;
            }
            
            else if (style_bool) && 
                (match (css__parse_outline_style(sheet , strings , vector , ctx , style_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                style_bool = false;
                error = CSS_OK; 
            }
            else if (width) && 
                (match (css__parse_outline_color(sheet , strings , vector , ctx , width_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                width = false;
                error = CSS_OK;
            }
            match error {
                CSS_OK => {
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if *ctx == prev_ctx {
                break;
            }
        }
        if color {
            css_stylesheet::css__stylesheet_style_appendOPV(color_style , CSS_PROP_OUTLINE_COLOR , 0 , OUTLINE_COLOR_INVERT );
        }
        if style_bool {
            css_stylesheet::css__stylesheet_style_appendOPV(style_style , CSS_PROP_OUTLINE_STYLE , 0 , OUTLINE_STYLE_NONE );   
        }
        if width {
            css_stylesheet::css__stylesheet_style_appendOPV(width_style , CSS_PROP_OUTLINE_WIDTH , 0 , OUTLINE_WIDTH_MEDIUM );
        }

        css_stylesheet::css__stylesheet_merge_style(style , color_style);
        css_stylesheet::css__stylesheet_merge_style(style , style_style);
        css_stylesheet::css__stylesheet_merge_style(style , width_style);

        CSS_OK
    }

    
    /**
    * Parse padding
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_padding(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut side_length: ~[i32] = ~[];
        let mut side_unit: ~[u32] = ~[];
        let mut side_count: u32 = 0;
        let mut token: &@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        if is_css_inherit(strings , token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_TOP);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_RIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_BOTTOM);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_LEFT);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings , token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            let (length_val , unit_val , result) = css__parse_unit_specifier(sheet , vector, ctx, UNIT_PX as u32);
            match result {
                CSS_OK => {
                    side_length.push(length_val.unwrap() as i32);
                    side_unit.push(unit_val.unwrap());
                    if (side_unit[side_count] & (UNIT_ANGLE as u32)) > 0 {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    if (side_unit[side_count] & (UNIT_TIME as u32)) > 0{
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    if (side_unit[side_count] & (UNIT_FREQ as u32)) > 0{
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    if side_unit[side_count] < 0 {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    side_count += 1;
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[3] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[3] as u32);
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * Parse pause
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_pause(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut first_token: &@css_token;
        let mut token: &@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }

        first_token = &vector[*ctx];
        let mut error = css__parse_pause_before(sheet,strings, vector, ctx, style);
        
        match error {
            CSS_OK=> {
                consumeWhitespace(vector, ctx);

                token = &vector[*ctx];
                if (*ctx >= vector.len() )  {
                    /* no second token, re-parse the first */
                    *ctx = orig_ctx;
                    error =  css__parse_pause_after(sheet, strings, vector, ctx, style);
                } 
                else {
                    /* second token - might be useful */
                    if ( is_css_inherit(strings, token)) {
                        /* another bogus inherit */
                        error = CSS_INVALID;
                    } 
                    else {
                        error =  css__parse_pause_after(sheet, strings, vector, ctx, style);
                        match (error) {
                             CSS_OK => { 
                                /* second token parsed */
                                if ( is_css_inherit(strings, first_token)) {
                                    /* valid second token after inherit */
                                    error = CSS_INVALID;
                                }
                            },
                            _=> {
                                /* second token appears to be junk re-try with first */
                                *ctx = orig_ctx;
                                error =  css__parse_pause_after(sheet, strings, vector, ctx, style);
                            }
                        }
                    }
                }
            },
            _=>{
                *ctx = orig_ctx;
            }
        }
       return error;
    }


    /**
    * Parse play_during
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_play_during(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx = *ctx;
        let mut token: &@css_token;
        let mut flags: u8 = 0;
        let mut value: u16 = 0;
        let mut uri_snumber: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        *ctx += 1;

        match token.token_type {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , INHERIT as uint) {
                    flags = flags | FLAG_INHERIT as u8;
                }
                else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , NONE as uint) {
                    value = PLAY_DURING_NONE as u16;
                }
                else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , AUTO as uint) {
                    value = PLAY_DURING_AUTO as u16;
                }
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            },
            CSS_TOKEN_URI  => {
                let mut modifiers:int = 0;
                value = PLAY_DURING_URI as u16;

                let mut uri:arc::RWARC<~lwc_string>;
                match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()) {
                    (CSS_OK, Some(x)) => {
                        uri =x;
                    },
                    (error,_) => {
                        *ctx = orig_ctx;
                        return error;
                    }
                }
                uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri)) as u32;

                while modifiers < 2 {
                    consumeWhitespace(vector, ctx);

                    if *ctx >= vector.len() {
                        return CSS_INVALID;
                    }

                    token=&vector[*ctx];

                    match token.token_type {
                        CSS_TOKEN_IDENT  => {
                            if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , MIX as uint) {
                                if value & (PLAY_DURING_MIX as u16) == 0 {
                                    value |= (PLAY_DURING_MIX as u16);
                                }
                                else {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                            }
                            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , REPEAT as uint) {
                                if value & (PLAY_DURING_REPEAT as u16) == 0 {
                                    value |= (PLAY_DURING_REPEAT as u16);
                                }
                                else {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                            }
                            else {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                            *ctx = *ctx + 1;
                        }
                        _ => {}
                    }
                    modifiers += 1;
                }
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        css_stylesheet::css__stylesheet_style_appendOPV(style ,CSS_PROP_PLAY_DURING , flags , value);
        if ((flags & FLAG_INHERIT as u8)==0 && (value & PLAY_DURING_TYPE_MASK as u16)==PLAY_DURING_URI as u16) {
            css_stylesheet::css__stylesheet_style_append(style , uri_snumber);
        }
        CSS_OK
    }

    
    /**
    * Parse quotes
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_quotes(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        let orig_ctx:uint = *ctx;
        if *ctx >= vector.len() {
            return CSS_INVALID;
        }

        let mut token = &vector[*ctx];
        *ctx += 1;
        
        match (token.token_type) {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
                    css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_QUOTES);
                }
                else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint)  {
                    css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_QUOTES, 0, QUOTES_NONE );
                }
            },
            CSS_TOKEN_STRING  => {
                let mut first: bool =true;
                
                loop {

                    match token.token_type {
                        CSS_TOKEN_STRING =>{
                            let mut open_snumber:u32;
                            let mut close_snumber:u32;
                            open_snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone())) as u32;
                            consumeWhitespace(vector, ctx);
                            
                            if (*ctx < vector.len()) {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            } 

                            token=&vector[*ctx];
                            *ctx += 1;
                            match token.token_type {
                                CSS_TOKEN_STRING  => {},
                                _=> {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                            }
                            close_snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone())) as u32;
                            consumeWhitespace(vector, ctx); 
                            match first {
                                true => css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_QUOTES, 0, QUOTES_STRING ),
                                false=> css_stylesheet::css__stylesheet_style_append(style, QUOTES_STRING as u32)
                            }
                            
                            css_stylesheet::css__stylesheet_style_append(style, open_snumber);
                            css_stylesheet::css__stylesheet_style_append(style, close_snumber);

                            first =false;
                            if (*ctx < vector.len()) {
                                break;
                            }
                            token=&vector[*ctx];
                            match token.token_type {
                                CSS_TOKEN_STRING  => {},
                                _=> {
                                    break;
                                }
                            }
                            if (*ctx < vector.len()) {
                                break;
                            } 
                            token=&vector[*ctx];
                            *ctx += 1;
                        },
                        _=>break
                    }
                    css_stylesheet::css__stylesheet_style_append(style, QUOTES_NONE as u32);
                }
            },
            _=>  {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * Parse text_decoration
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_text_decoration(_: @mut css_stylesheet , strings: &mut ~css_propstrings ,vector:&~[@css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        let orig_ctx:uint= *ctx;
        let mut token: &@css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        *ctx += 1;

        match token.token_type {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
                    css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_TEXT_DECORATION);
                }
                else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint)  {
                    css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_TEXT_DECORATION, 0, TEXT_DECORATION_NONE );
                }
                else {
                    let mut value: u16 = 0 ;
                    while (*ctx < vector.len()) {
                        if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), UNDERLINE as uint) {
                            if ((value & TEXT_DECORATION_UNDERLINE ) == 0) {
                                value |= TEXT_DECORATION_UNDERLINE ;
                            }
                            
                            else {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                        }
                        else if  strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), OVERLINE as uint) {
                            if ((value & TEXT_DECORATION_OVERLINE ) == 0) {
                                value |= TEXT_DECORATION_OVERLINE ;
                            }
                            else {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                        }
                        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LINE_THROUGH as uint) {
                            if ((value & TEXT_DECORATION_LINE_THROUGH ) == 0) {
                                value |= TEXT_DECORATION_LINE_THROUGH ;
                            }
                            else {
                                *ctx = orig_ctx;
                                return CSS_INVALID;

                            }
                        }
                        else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BLINK as uint) {
                            if ((value & (TEXT_DECORATION_BLINK )) == 0) {
                                value |= TEXT_DECORATION_BLINK ;
                            }
                            else {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                        }
                        else {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        consumeWhitespace(vector, ctx);
                        
                        if *ctx >= vector.len() {
                            break;
                        }

                        token=&vector[*ctx];
                        *ctx += 1;
                        match (token.token_type) {
                            CSS_TOKEN_IDENT  => {},
                            _=> {
                                break;
                            }
                        }
                        css_stylesheet::css__stylesheet_style_appendOPV(style,  CSS_PROP_TEXT_DECORATION, 0, value);
                    }
                }
            },
            _=> {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * Parse voice_family
    *
    * \param sheet   Stylesheet 
    * \param vector  Vector of tokens to process
    * \param ctx     Pointer to vector iteration ctx
    * \return CSS_OK on success, 
    *     CSS_INVALID if the input is not valid
    * Post condition: \a @ctx is updated with the next token to process
    *         If the input is invalid, then \a @ctx remains unchanged.
    */
    fn css__parse_voice_family(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings, vector:&~[@css_token], ctx: @mut uint, result: @mut css_style) -> css_error {
    
        let orig_ctx = *ctx;
       
        /* [ IDENT+ | STRING ] [ ',' [ IDENT+ | STRING ] ]* | IDENT(inherit)
         * 
         * In the case of IDENT+, any whitespace between tokens is collapsed to
         * a single space
         */
        if *ctx >= vector.len() {
            return CSS_INVALID
        }


        let token = &vector[*ctx];
        *ctx += 1;

        match token.token_type {
            CSS_TOKEN_IDENT  | CSS_TOKEN_STRING  => {}, 
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID
            }
        } 

        if match token.token_type { CSS_TOKEN_IDENT  => true, _ => false } &&
                strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
            
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_VOICE_FAMILY)
        } 
        else {
            *ctx = orig_ctx;
            let error = css__comma_list_to_style(sheet , strings , vector , ctx , Some(@voice_family_reserved) , Some(@voice_family_value) , result);
            match error {
                CSS_OK => {},
                _ => {
                    *ctx = orig_ctx;
                    return error;
                }
            }
            css_stylesheet::css__stylesheet_style_append(result, VOICE_FAMILY_END as u32);
        }
        CSS_OK
    }
      
}//end of impl css_properties


/**
* Parse list-style-type value
*
* \param string css_propstrings
* \param token  tokens to process
* \return value Option of u16 (Some(x) if CSS_OK else None)
* \return CSS_OK on success, 
*     CSS_INVALID if the input is not valid
* Post condition: \a @ctx is updated with the next token to process
*         If the input is invalid, then \a @ctx remains unchanged.
*/
pub fn css__parse_list_style_type_value(strings: &mut ~css_propstrings , token:&@css_token) -> (Option<u16> , css_error) {
    if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , DISC as uint) {
        return (Some(LIST_STYLE_TYPE_DISC ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , CIRCLE as uint) {
        return (Some(LIST_STYLE_TYPE_CIRCLE ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , SQUARE as uint) {
        return (Some(LIST_STYLE_TYPE_SQUARE ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , DECIMAL as uint) {
        return (Some(LIST_STYLE_TYPE_DECIMAL ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , DECIMAL_LEADING_ZERO as uint) {
        return (Some(LIST_STYLE_TYPE_DECIMAL_LEADING_ZERO ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , LOWER_ROMAN as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_ROMAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , UPPER_ROMAN as uint) {
        return (Some(LIST_STYLE_TYPE_UPPER_ROMAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , LOWER_GREEK as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_GREEK ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , LOWER_LATIN as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_LATIN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , UPPER_LATIN as uint) {
        return (Some(LIST_STYLE_TYPE_UPPER_LATIN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , ARMENIAN as uint) {
        return (Some(LIST_STYLE_TYPE_ARMENIAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , GEORGIAN as uint) {
        return (Some(LIST_STYLE_TYPE_GEORGIAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , LOWER_ALPHA as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_ALPHA ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , UPPER_ALPHA as uint) {
        return (Some(LIST_STYLE_TYPE_UPPER_ALPHA ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone() , NONE as uint) {
        return (Some(LIST_STYLE_TYPE_NONE ) , CSS_OK);
    }
    else {
        return (None , CSS_INVALID);
    }
}


/**
 * Determine if a given font-family ident is reserved
 *
 * \param strings Propstrings
 * \param ident  IDENT to consider
 * \return True if IDENT is reserved, false otherwise
 */
pub fn font_family_reserved(strings:&mut ~css_propstrings, ident:&@css_token) -> bool {

    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), SERIF as uint) ||
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), SANS_SERIF as uint) ||
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), CURSIVE as uint) ||
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), FANTASY as uint) ||
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), MONOSPACE as uint)
}


/**
 * Convert a font-family token into a bytecode value
 *
 * \param strings Propstrings
 * \param token  Token to consider
 * \param first  Whether the token is the first
 * \return Bytecode value
 */
pub fn font_family_value(strings:&mut ~css_propstrings, token:&@css_token, first:bool) -> u32 {
    let mut value:u16;
    
    match token.token_type{
        CSS_TOKEN_IDENT  => {
            if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SERIF as uint) {
                value = FONT_FAMILY_SERIF
            }    
            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SANS_SERIF as uint) {
                value = FONT_FAMILY_SANS_SERIF 
            }    
            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CURSIVE as uint) {
                value = FONT_FAMILY_CURSIVE
            }    
            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FANTASY as uint) {
                value = FONT_FAMILY_FANTASY
            }    
            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MONOSPACE as uint) {
                value = FONT_FAMILY_MONOSPACE
            }    
            else {
                value = FONT_FAMILY_IDENT_LIST 
            }    
        },
        _ =>  value = FONT_FAMILY_STRING 
    } 
    
    if first {
      buildOPV(CSS_PROP_FONT_FAMILY, 0, value )  as u32
    }
    else{
        value as u32
    }  
}


pub fn parse_system_font(sheet: @mut css_stylesheet , strings:&mut ~css_propstrings , style: @mut css_style , system_font: css_system_font) -> css_error{
    match system_font.style {
        CSS_FONT_STYLE_NORMAL => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_NORMAL );
        },
        CSS_FONT_STYLE_ITALIC => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_ITALIC );  
        },
        CSS_FONT_STYLE_OBLIQUE => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_OBLIQUE );  
        },
        _ => {
            return CSS_BADPARM;
        }
    }

    match system_font.variant {
        CSS_FONT_VARIANT_NORMAL => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_VARIANT , 0 , FONT_VARIANT_NORMAL );
        },
        CSS_FONT_VARIANT_SMALL_CAPS => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_VARIANT , 0 , FONT_VARIANT_SMALL_CAPS );  
        },
        _ => {
            return CSS_BADPARM;
        }
    }

    match system_font.weight {
        CSS_FONT_WEIGHT_NORMAL => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_NORMAL );
        },
        CSS_FONT_WEIGHT_BOLD => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_BOLD );  
        },
        CSS_FONT_WEIGHT_BOLDER => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_BOLDER );  
        },
        CSS_FONT_WEIGHT_LIGHTER => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_LIGHTER );  
        },
        CSS_FONT_WEIGHT_100 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_100 );  
        },
        CSS_FONT_WEIGHT_200 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_200 );  
        },
        CSS_FONT_WEIGHT_300 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_300 );  
        },
        CSS_FONT_WEIGHT_400 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_400 );  
        },
        CSS_FONT_WEIGHT_500 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_500 );  
        },
        CSS_FONT_WEIGHT_600 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_600 );  
        },
        CSS_FONT_WEIGHT_700 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_700 );  
        },
        CSS_FONT_WEIGHT_800 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_800 );  
        },
        CSS_FONT_WEIGHT_900 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_900 );  
        },
        _ => {
            return CSS_BADPARM;
        }
    }

    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_SIZE , 0 , FONT_SIZE_DIMENSION as u16);
    css_stylesheet::css__stylesheet_style_vappend(style , [system_font.size.size as u32 , system_font.size.unit as u32]);
    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_LINE_HEIGHT , 0 , LINE_HEIGHT_DIMENSION as u16);
    css_stylesheet::css__stylesheet_style_vappend(style , [system_font.line_height.size as u32 , system_font.line_height.unit as u32]);

    if strings.lwc_string_caseless_isequal(system_font.family.clone() , SERIF as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_SERIF as u16);
    }
    else if strings.lwc_string_caseless_isequal(system_font.family.clone() , SANS_SERIF as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_SANS_SERIF as u16);
    }
    else if strings.lwc_string_caseless_isequal(system_font.family.clone() , CURSIVE as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_CURSIVE as u16);
    }
    else if strings.lwc_string_caseless_isequal(system_font.family.clone() , FANTASY as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_FANTASY as u16);
    }
    else if strings.lwc_string_caseless_isequal(system_font.family.clone() , MONOSPACE as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_MONOSPACE as u16);
    }
    else {
        let mut sNumber: u32;
        sNumber = sheet.css__stylesheet_string_add(lwc_string_data(system_font.family.clone())) as u32;

        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_STRING as u16);           
        css_stylesheet::css__stylesheet_style_append(style , sNumber);
    }
    css_stylesheet::css__stylesheet_style_append(style , FONT_FAMILY_END as u32);

    CSS_INVALID
}


/**
 * Determine if a given voice-family ident is reserved
 *
 * \param strings Propstrings
 * \param ident  IDENT to consider
 * \return True if IDENT is reserved, false otherwise
 */
pub fn voice_family_reserved(strings: &mut ~css_propstrings, ident:&@css_token) -> bool {
    
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), MALE as uint) ||
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), FEMALE as uint) ||
    strings.lwc_string_caseless_isequal(ident.idata.get_ref().clone(), CHILD as uint) 
}


/**
 * Convert a voice-family token into a bytecode value
 *
 * \param strings Propstrings
 * \param token  Token to consider
 * \return Bytecode value
 */
pub fn voice_family_value(strings: &mut ~css_propstrings, token:&@css_token, first:bool) -> u32
{
     
    let value = match token.token_type {
        CSS_TOKEN_IDENT  => {
            if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MALE as uint){
                VOICE_FAMILY_MALE
            }
            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FEMALE as uint){
                VOICE_FAMILY_FEMALE   
            }
            else if strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CHILD as uint){
                VOICE_FAMILY_CHILD
            }
            else{
                VOICE_FAMILY_IDENT_LIST
            }
        },
        _ => VOICE_FAMILY_STRING     
    }; 
   
    if first {
        buildOPV(CSS_PROP_VOICE_FAMILY, 0, value ) 
    }
    else {
        value as u32  
    }   
}

/**
* Create a string from a list of IDENT/S tokens if the next token is IDENT
* or references the next token's string if it is a STRING
*
* \param sheet   Stylesheet 
* \param vector  Vector of tokens to process
* \param ctx     Pointer to vector iteration ctx
* \param reserved   Callback to determine if an identifier is reserved
* \return result Option of ~str (Some(x) if CSS_OK else None)
* \return CSS_OK on success, 
*     CSS_INVALID if the input is not valid
* Post condition: \a @ctx is updated with the next token to process
*         If the input is invalid, then \a @ctx remains unchanged.
*/
pub fn css__ident_list_or_string_to_string(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings, vector:&~[@css_token], ctx:@mut uint, reserved:Option<reserved_fn>)
    -> (css_error, Option<~str>) {
    
    if *ctx >= vector.len() {
        return (CSS_INVALID,None)
    }
    
    let mut token = &vector[*ctx];  
    
    match token.token_type {
        CSS_TOKEN_STRING  => {
            token = &vector[*ctx];
            *ctx += 1; //Iterate
            return (CSS_OK,Some(lwc_string_data(token.idata.get_ref().clone())))
        },  
        CSS_TOKEN_IDENT  =>  return css__ident_list_to_string(sheet , strings , vector , ctx , reserved),
        _ => return (CSS_INVALID,None)
    }
}


/**
* Create a string from a list of IDENT/S tokens
*
* \param vector  Vector of tokens to process
* \param ctx     Pointer to vector iteration ctx
* \param reserved   Callback to determine if an identifier is reserved
* \return result Option of ~str (Some(x) if CSS_OK else None)
* \return CSS_OK on success, 
*     CSS_INVALID if the input is not valid
* Post condition: \a @ctx is updated with the next token to process
*         If the input is invalid, then \a @ctx remains unchanged.
*/
pub fn css__ident_list_to_string(_: @mut css_stylesheet , strings: &mut ~css_propstrings, vector:&~[@css_token],
    ctx: @mut uint , reserved:Option<reserved_fn>) -> (css_error , Option<~str>) {

    let orig_ctx = *ctx;
    let mut token: &@css_token;
    let mut token_buffer_string: ~str = ~"";

    if *ctx >= vector.len() {
        return (CSS_INVALID , None);
    }

    token = &vector[*ctx];
    *ctx += 1;

    loop {
        match token.token_type {
            CSS_TOKEN_IDENT  => {
                match reserved {
                    None => {},
                    Some(reserved_function) => {
                        if (*reserved_function)(strings , token) {
                            *ctx = orig_ctx;
                            return (CSS_INVALID , None);
                        }
                    }
                }
                token_buffer_string.push_str(lwc_string_data(token.idata.get_ref().clone()));
            },
            CSS_TOKEN_S => {
                token_buffer_string.push_str(~" ");
            },
            _ => {
                break;
            }
        }
        if *ctx >= vector.len() {
            break;
        }

        token = &vector[*ctx];
        *ctx += 1;
    }

    if *ctx >= vector.len() {
        *ctx -= 1;
    }
    
    token_buffer_string.trim_right();

    return (CSS_OK , Some(token_buffer_string));
}


/**
* Parse a comma separated list, converting to bytecode
*
* \param vector  Vector of tokens to process
* \param ctx     Pointer to vector iteration ctx
* \param reserved   Callback to determine if an identifier is reserved
* \param get_value  Callback to retrieve bytecode value for a token
* \return CSS_OK on success, 
*     CSS_INVALID if the input is not valid
* Post condition: \a @ctx is updated with the next token to process
*         If the input is invalid, then \a @ctx remains unchanged.
*/
pub fn css__comma_list_to_style(sheet: @mut css_stylesheet , strings: &mut ~css_propstrings, vector:&~[@css_token], 
    ctx: @mut uint , reserved:Option<reserved_fn> , get_value: Option<get_value_fn> , style: @mut css_style) -> css_error {

    let orig_ctx = *ctx;
    let mut prev_ctx = orig_ctx;
    let mut token: &@css_token;
    let mut first = true;
    let mut value: u32 = 0;

    if *ctx >= vector.len() {
        return CSS_INVALID;
    }

    token = &vector[*ctx];
    *ctx += 1;

    loop {
        match token.token_type {
            CSS_TOKEN_IDENT  => {
                match get_value {
                    None => {},
                    Some(get_value_function) => {
                        value = (*get_value_function)(strings , token , first);
                    }
                }
                match reserved {
                    None => {},
                    Some(reserved_function) => {
                        if !((*reserved_function)(strings , token)) {
                            *ctx = prev_ctx;
                            let (error , some_string) = css__ident_list_to_string(sheet , strings , vector , ctx , reserved);
                            match error {
                                CSS_OK => {},
                                _ => {
                                    *ctx = orig_ctx;
                                    return error;
                                }
                            }

                            let snumber = sheet.css__stylesheet_string_add(some_string.unwrap());
                            css_stylesheet::css__stylesheet_style_append(style , value);
                            css_stylesheet::css__stylesheet_style_append(style , snumber as u32);
                        }
                        else {
                            css_stylesheet::css__stylesheet_style_append(style , value);
                        }
                    }
                }
            },
            CSS_TOKEN_STRING  => {
                match get_value {
                    None => {},
                    Some(get_value_function) => {
                        value = (*get_value_function)(strings , token , first);
                    }
                }
                let snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone()));
                css_stylesheet::css__stylesheet_style_append(style , value);
                css_stylesheet::css__stylesheet_style_append(style , snumber as u32);
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        consumeWhitespace(vector , ctx);
        token = &vector[*ctx];
        if  tokenIsChar(token , ',') {
            if *ctx >= vector.len() {
                break;
            }
            *ctx = *ctx + 1;
            consumeWhitespace(vector , ctx);
            token = &vector[*ctx];
            if *ctx >= vector.len() {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            match token.token_type {
                CSS_TOKEN_IDENT |CSS_TOKEN_STRING  => {},
                _ => {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }
        else {
            break;
        }
        first = false;
        prev_ctx = *ctx;
        token = &vector[*ctx];
        *ctx += 1;
    }

    CSS_OK
}

/**
 * Parse border_side
 *
 * \param sheet   Stylesheet  
 * \param strings Propstrings
 * \param vector  Vector of tokens to process
 * \param ctx     Pointer to vector iteration context
 * \param result  resulting style
 * \return CSS_OK on success,
 *      CSS_INVALID if the input is not valid
 *
 * Post condition: \a @ctx is updated with the next token to process
 *          If the input is invalid, then \a @ctx remains unchanged.
 */
pub fn css__parse_border_side(sheet: @mut css_stylesheet, strings: &mut ~css_propstrings , vector: &~[@css_token] , ctx: @mut uint , result_style: @mut css_style , side: border_side_e) -> css_error { 
    let orig_ctx = *ctx;
    let mut prev_ctx: uint;
    let mut color: bool = true;
    let mut style: bool = true;
    let mut width: bool = true;
    let color_style: @mut css_style;
    let style_style: @mut css_style;
    let width_style: @mut css_style;
    let mut token: &@css_token;

    if *ctx >= vector.len() {
        return CSS_INVALID;
    }

    token = &vector[*ctx];
    
    if (is_css_inherit(strings , token)) {
        css_stylesheet::css_stylesheet_style_inherit(result_style , unsafe{cast::transmute(CSS_PROP_BORDER_TOP_COLOR as uint + side as uint)});
        css_stylesheet::css_stylesheet_style_inherit(result_style, unsafe{cast::transmute(CSS_PROP_BORDER_TOP_STYLE as uint + side as uint)});
        css_stylesheet::css_stylesheet_style_inherit(result_style, unsafe{cast::transmute(CSS_PROP_BORDER_TOP_WIDTH as uint + side as uint)});
    }
    
    *ctx = *ctx + 1;
    color_style = css_stylesheet::css__stylesheet_style_create(sheet);
    style_style = css_stylesheet::css__stylesheet_style_create(sheet);
    width_style = css_stylesheet::css__stylesheet_style_create(sheet);

     let mut error:css_error;
    /* Attempt to parse the various longhand properties */
    loop {
        prev_ctx = *ctx;
        error = CSS_OK;
        
        if *ctx >= vector.len() {
            *ctx = orig_ctx;
            return CSS_INVALID
        }
        
        token = &vector[*ctx];
        
        if is_css_inherit(strings , token) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        /* Try each property parser in turn, but only if we
         * haven't already got a value for this property.
         */
        if color && 
            match css__parse_border_side_color(sheet, strings, vector, ctx, color_style, 
                unsafe { cast::transmute(CSS_PROP_BORDER_TOP_COLOR as uint + side as uint)}) { CSS_OK =>{error = CSS_OK; true}, err =>{ error = err; false} } {
            color = false
        } 
        else if style && 
            match css__parse_border_side_style(sheet, strings, vector, ctx, style_style, 
                unsafe {cast::transmute( CSS_PROP_BORDER_TOP_STYLE as uint + side as uint)}) { CSS_OK =>{error = CSS_OK; true}, err =>{ error = err; false} } {
            style = false
        } else if width && 
            match css__parse_border_side_width(sheet, strings, vector, ctx, width_style, 
                unsafe { cast::transmute(CSS_PROP_BORDER_TOP_WIDTH as uint + side as uint)}) { CSS_OK =>{error = CSS_OK; true}, err =>{ error = err; false} } {
            width = false
        } 

        if match error { CSS_OK => true, _ => false } {
            consumeWhitespace(vector, ctx);

            if *ctx >= vector.len() {
                break;
            }
        
            //token = &vector[*ctx]; Not Used
        
        } else {
            /* Forcibly cause loop to exit */
            break;
        }
        
        if *ctx == prev_ctx {
            break
        }
    }

    if (style) {
        css_stylesheet::css__stylesheet_style_appendOPV(style_style, unsafe {cast::transmute(CSS_PROP_BORDER_TOP_STYLE as uint + side as uint)}, 0, BORDER_STYLE_NONE);
    }

    if (width) {
        css_stylesheet::css__stylesheet_style_appendOPV(width_style, unsafe {cast::transmute(CSS_PROP_BORDER_TOP_WIDTH as uint + side as uint)}, 0, BORDER_WIDTH_MEDIUM);
       
    }

    css_stylesheet::css__stylesheet_merge_style(result_style, color_style);
    
    css_stylesheet::css__stylesheet_merge_style(result_style, style_style);
    
    css_stylesheet::css__stylesheet_merge_style(result_style, width_style);

    match error {
        CSS_OK => CSS_OK,
        error => {
            *ctx = orig_ctx;
            error
        }
    }
    
}


/*******************************************************************************
Moved Autogenerated Parse/Properties functions for removing circular dependency
*********************************************************************************/
/**
 * Parse border_top
 *
 * \param strings Propstrings
 * \param vector  Vector of tokens to process
 * \param ctx     Pointer to vector iteration context
 * \param result  resulting style
 * \return CSS_OK on success,
 *      CSS_INVALID if the input is not valid
 *
 * Post condition: \a @ctx is updated with the next token to process
 *          If the input is invalid, then \a @ctx remains unchanged.
 */
pub fn css__parse_border_top(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, strings, vector, ctx, result, BORDER_SIDE_TOP)
}
 

/**
 * Parse border_bottom
 *
 * \param strings Propstrings
 * \param vector  Vector of tokens to process
 * \param ctx     Pointer to vector iteration context
 * \param result  resulting style
 * \return CSS_OK on success,
 *      CSS_INVALID if the input is not valid
 *
 * Post condition: \a @ctx is updated with the next token to process
 *          If the input is invalid, then \a @ctx remains unchanged.
 */
pub fn css__parse_border_bottom(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, strings, vector, ctx, result, BORDER_SIDE_BOTTOM)
}


/**
 * Parse border_left
 *
 * \param strings Propstrings
 * \param vector  Vector of tokens to process
 * \param ctx     Pointer to vector iteration context
 * \param result  resulting style
 * \return CSS_OK on success,
 *      CSS_INVALID if the input is not valid
 *
 * Post condition: \a @ctx is updated with the next token to process
 *          If the input is invalid, then \a @ctx remains unchanged.
 */
pub fn css__parse_border_left(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, strings, vector, ctx, result, BORDER_SIDE_LEFT)
}


/**
 * Parse border_right
 *
 * \param strings Propstrings
 * \param vector  Vector of tokens to process
 * \param ctx     Pointer to vector iteration context
 * \param result  resulting style
 * \return CSS_OK on success,
 *      CSS_INVALID if the input is not valid
 *
 * Post condition: \a @ctx is updated with the next token to process
 *          If the input is invalid, then \a @ctx remains unchanged.
 */
pub fn css__parse_border_right(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, strings, vector, ctx, result, BORDER_SIDE_RIGHT)
}