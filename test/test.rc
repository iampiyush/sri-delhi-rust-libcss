#[link(name = "test", vers = "1.0", author="Vipul Goel")];
#[crate_type = "lib"];

extern mod std;

use core::io::*;

pub struct log_entry {
	test:~str,
	file:~str,
	func:~str,
	status:~str
}

pub struct test_report {
	log_list:~[log_entry],
	file_handle:@Writer,
	is_logged:bool
}

#[unsafe_destructor]
impl Drop for test_report {
    fn finalize(&self) {
    	if self.is_logged==false {
    		self.do_forceful_log_dump() ;
    	}
    }
}

impl test_report {
	pub fn log_pass(&mut self, test_name : ~str , file_name : ~str , function_name : ~str ) {
		self.do_log(test_name ,file_name, function_name , ~"PASSED" );
	}

	pub fn log_fail(&mut self, test_name : ~str , file_name : ~str , function_name : ~str ) {
		self.do_log(test_name ,file_name, function_name , ~"FAIl" );
	}

	pub fn log_info(&mut self, test_name : ~str , file_name : ~str , function_name : ~str ) {
		self.do_log(test_name ,file_name, function_name , ~"INFO" );
	}

	// collects log in the memory and also print them on the console
	fn do_log(&mut self, test_name : ~str , file_name : ~str , function_name : ~str , result : ~str) {
		io::print(fmt!("\n\t \t [%s] [%s] [%s] = [%s] ",test_name,file_name,function_name,result));
		self.do_silent_log(test_name, file_name , function_name  , result ) ;
	}

	// Collects log silently in the memory
	pub fn do_silent_log(&mut self, test_name : ~str , file_name : ~str , function_name : ~str , result : ~str) {
		let a = log_entry{test:test_name , file:file_name , func:function_name , status:result };
		self.log_list.push(a);
	}

	// do log dump in the file
	pub fn do_log_dump(&mut self) {
		self.is_logged = true ;
		self.file_handle.write_line(fmt!("Test Name,File Name,Function Name,Status"));
		for self.log_list.each() |lg| {
			self.file_handle.write_line(fmt!("%s,%s,%s,%s",lg.test,lg.file,lg.func,lg.status));
		}
	}

	// do forcefull logging in the end, if user not done file logging during usage
	pub fn do_forceful_log_dump(&self) {
		self.file_handle.write_line(fmt!("Test Name,File Name,Function Name,Status"));
		for self.log_list.each() |lg| {
			self.file_handle.write_line(fmt!("%s,%s,%s,%s",lg.test,lg.file,lg.func,lg.status));
		}
	}
}

pub fn test_report(logfile : &str) -> Result<~test_report,~str> {
	let flag : &[FileFlag] = &[Append,Create] ;
	if logfile.len()==0 {
		match file_writer(&Path(&"test_log.csv"),flag ) {
			Ok(x)  => Ok(~test_report{log_list:~[] , file_handle:x , is_logged:false}),
			Err(_) => Err(~"Error opening file test_log.csv in open/append modes")
		}
	}
	else {
		match file_writer(&Path(logfile),flag ) {
			Ok(x)  => Ok(~test_report{log_list:~[] , file_handle:x , is_logged:false}),
			Err(_) => Err(~"Error opening custom file in open/append modes")
		}
	}
}

// ~test_report code ends here