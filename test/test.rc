#[link(name = "test", vers = "1.0", author="Vipul Goel")];
#[crate_type = "lib"];

extern mod std;

use core::io::*;

pub struct log_entry {
	testfile_name: ~str,
	external_argument : ~str,
	module_name: ~str,
	file_name:~str,
	function_name:~str,
	test_argument:~str,
	expected_result: ~str,
	obtained_result: ~str,	
	result: ~str,
	comment:~str
}

pub struct test_report {
	log_list:~[log_entry],
	file_handle:@Writer,
	is_logged:bool
}

#[unsafe_destructor]
impl Drop for test_report {
    fn finalize(&self) {
    	if (self.is_logged == false) {
    		self.do_forceful_log_dump() ;
    	}
    }
}

impl test_report {
	pub fn pass(&mut self, testfile_name: ~str, external_argument : ~str, module_name: ~str, file_name : ~str , function_name : ~str, test_argument : ~str, expected_result: ~str, obtained_result: ~str, comment: ~str) {
		self.do_log(testfile_name,external_argument,  module_name, file_name, function_name, test_argument, expected_result, obtained_result, ~"PASS", comment );
	}

	pub fn fail(&mut self, testfile_name: ~str, external_argument : ~str, module_name: ~str, file_name : ~str , function_name : ~str, test_argument : ~str, expected_result: ~str, obtained_result: ~str, comment: ~str) {		
		self.do_log(testfile_name, external_argument, module_name, file_name, function_name, test_argument, expected_result, obtained_result, ~"FAIL", comment );
	}

	pub fn info(&mut self, testfile_name: ~str, external_argument : ~str, module_name: ~str, file_name : ~str , function_name : ~str,expected_result: ~str, obtained_result: ~str, comment : ~str ) {			
		self.do_log(testfile_name, external_argument, module_name, file_name, function_name, ~"", ~"",expected_result , obtained_result, comment );
	}

	// collects log in the memory and also print them on the console
	fn do_log(&mut self, testfile_name: ~str, external_argument : ~str, module_name: ~str, file_name : ~str , function_name : ~str, test_argument : ~str, expected_result: ~str, obtained_result: ~str, result:~str, comment : ~str) {
		if result==~"" {
			io::print(fmt!("\n[%s]::[%s]::[%s]::[%s]::[%s] Test:[%s]::[%s]::[%s]::[%s]", testfile_name, external_argument, module_name, file_name, function_name, test_argument, expected_result, obtained_result, comment));	
		}
		else {
			io::print(fmt!("\n[%s]::[%s]::[%s]::[%s]::[%s] Test:[%s]::[%s]::[%s]::[%s] %s", testfile_name, external_argument, module_name, file_name,function_name, test_argument, expected_result, obtained_result, result, comment));	
		}
				
		self.do_silent_log(testfile_name, external_argument, module_name, file_name , function_name, test_argument, expected_result, obtained_result, result, comment);
	}

	// Collects log silently in the memory
	fn do_silent_log(&mut self, testfile_name: ~str, external_argument : ~str, module_name: ~str, file_name : ~str , function_name : ~str, test_argument : ~str, expected_result: ~str, obtained_result: ~str, result: ~str, comment : ~str) {
		let a = log_entry {
			testfile_name: testfile_name,
			external_argument : external_argument,
			module_name:module_name, 
			file_name:file_name , 
			test_argument:test_argument ,  
			expected_result: expected_result,
			obtained_result: obtained_result,		
			function_name:function_name , 
			result:result,
			comment:comment 
		};
		
		self.log_list.push(a);
	}

	// do log dump in the file
	pub fn do_log_dump(&mut self) {
		self.is_logged = true;
		self.do_forceful_log_dump();
	}

	// do forcefull logging in the end, if user not done file logging during usage
	fn do_forceful_log_dump(&self) {
		self.file_handle.write_line("");
		self.file_handle.write_line(fmt!("Test File, External argument, Module, File, Function, Internal test argument, Expected output, Obtained output, Result, Comment"));
		self.file_handle.write_line("");
		for self.log_list.each() |log_entry| {
			self.file_handle.write_line (
					fmt!("%s,%s,%s,%s,%s,%s,%s, %s, %s, %s",
							log_entry.testfile_name,
							log_entry.external_argument,
							log_entry.module_name,
							log_entry.file_name,
							log_entry.function_name,
							log_entry.test_argument, 
							log_entry.expected_result,
							log_entry.obtained_result,
							log_entry.result,
							log_entry.comment
						)
				);
		}
	}
}

pub fn test_report(logfile : &str) -> Result<~test_report,~str> {
	let flag : &[FileFlag] = &[Append,Create] ;
	if logfile.len()==0 {
		match file_writer(&Path(&"test_log.csv"),flag ) {
			Ok(x)  => Ok(~test_report{log_list:~[] , file_handle:x , is_logged:false}),
			Err(_) => Err(~"Error opening file test_log.csv in open/append modes")
		}
	}
	else {
		match file_writer(&Path(logfile),flag ) {
			Ok(x)  => Ok(~test_report{log_list:~[] , file_handle:x , is_logged:false}),
			Err(_) => Err(~"Error opening custom file in open/append modes")
		}
	}
}

// ~test_report code ends here